<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8">
  <title>生成AIパスポート試験問題集_V7</title>
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <script src="https://cdn.tailwindcss.com"></script>
  <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;700&family=Noto+Sans+JP:wght@400;700&display=swap" rel="stylesheet">
  <style>
    body { font-family: 'Noto Sans JP', 'Inter', sans-serif; background-color: #f0f4f8; padding: 20px; }
    .card { background: white; padding: 24px; border-radius: 12px; box-shadow: 0 4px 12px rgba(0,0,0,0.08); max-width: 650px; margin: auto; }
    button, select { margin-top: 12px; padding: 12px; font-size: 16px; width: 100%; border-radius: 8px; border: 1px solid #d1d5db; transition: all 0.2s ease-in-out; }
    button:hover:not(:disabled) { transform: translateY(-2px); box-shadow: 0 2px 6px rgba(0,0,0,0.1); }
    button:disabled { background-color: #d1d5db; cursor: not-allowed; }
    .small { font-size: 14px; color: #4b5563; }
    hr { margin: 24px 0; border-color: #e5e7eb; }
    .dialog-container { position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.5); display: flex; justify-content: center; align-items: center; z-index: 1000; opacity: 0; animation: fadeIn 0.3s forwards; }
    .dialog { background: white; padding: 24px; border-radius: 12px; box-shadow: 0 10px 25px rgba(0,0,0,0.1); max-width: 90%; width: 500px; max-height: 80%; overflow-y: auto; transform: scale(0.95); animation: zoomIn 0.3s forwards; }
    .spinner { border: 4px solid rgba(0, 0, 0, 0.1); width: 36px; height: 36px; border-radius: 50%; border-left-color: #3b82f6; animation: spin 1s ease infinite; }
    @keyframes spin { to { transform: rotate(360deg); } }
    @keyframes fadeIn { to { opacity: 1; } }
    @keyframes zoomIn { to { transform: scale(1); } }
    /* Calendar Styles */
    #calendar { font-size: 14px; }
    #calendar th, #calendar td { text-align: center; padding: 8px; }
    #calendar td.today { background-color: #fef3c7; border-radius: 50%; }
    #calendar td.studied { background-color: #93c5fd; color: white; border-radius: 50%; font-weight: bold; }
    /* Sakura Petals */
    .sakura-container {
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        pointer-events: none;
        overflow: hidden;
        z-index: 999;
    }
    .sakura-petal {
        position: absolute;
        width: 15px;
        height: 15px;
        background-color: #ffc0cb;
        border-radius: 50% 10% 50% 10%;
        transform: rotate(45deg);
        opacity: 0;
        animation: fall linear infinite;
    }
    @keyframes fall {
        0% {
            transform: translate(0, -100px) rotate(0deg);
            opacity: 1;
        }
        100% {
            transform: translate(50px, 100vh) rotate(360deg);
            opacity: 0;
        }
    }
  </style>
</head>
<body>
  <div class="card" id="app">
    <!-- Main content will be rendered here -->
  </div>

  <div id="userIdFooter" class="text-center text-xs text-gray-400 mt-4"></div>
  
  <script>
    // --- DATA ---
    const chapters = {
      "第1章 AI（人工知能）": [
        { question: "次のうち、「AI(人工知能)」と「ロボット」の区別に関する説明として誤っているものを1つ選びなさい。", options: ["1.AIはデータを分析し、学習して知識を構築するが、物理的な操作を行うことはない。", "2.ロボットは物理的な作業を行うが、AIのようにデータを分析したり学習する能力は持っていない。", "3.AIはソフトウェアであり、物理的な形を持たないが、ロボットはハードウェアとして存在する。", "4.ロボットはAI技術を利用して自律的に学習し、周囲の環境に適応することができる。"], answer: 1, explanation: "ロボットはAIを内蔵することで、AIのようにデータを分析したり学習する能力を持つことができます。" },
        { question: "次のうち、「教師なし学習」に関する説明として誤っているものを1つ選びなさい。", options: ["1.教師なし学習では、ラベルの付いていないデータを用いてモデルをトレーニングし、データの構造やパターンを発見する。", "2.教師なし学習の代表的な手法には、クラスタリングや次元削減が含まれる。", "3.教師なし学習では、モデルは与えられた正解に基づいてフィードバックを受け、予測精度を向上させる。", "4.教師なし学習は、データの分類や特徴量の抽出など、さまざまなタスクに応用される。"], answer: 2, explanation: "「正解に基づくフィードバック」は教師あり学習の特徴です。" },
        { question: "次のうち、「AIの歴史」に関する説明として誤っているものを1つ選びなさい。", options: ["1.第一次AIブームは、主に探索と推論の技術を中心に発展した。", "2.第二次AIブームでは、エキスパートシステムが広く利用されるようになったが、ブームは終息し「AIの冬」と呼ばれる時期が訪れた。", "3.第三次AIブームは、ビッグデータの活用とディープラーニングの発展によって引き起こされた。", "4.第三次AIブーム以降、AIは特に金融業界にのみ限定して応用されている。"], answer: 3, explanation: "AIは金融業界だけでなく、医療、製造、交通など多岐にわたる分野で応用されています。" },
        { question: "次のうち、「強化学習」に関する説明として正しいものを1つ選びなさい。", options: ["1.強化学習では、エージェントがすべての行動に対して即座に報酬を受け取る。", "2.強化学習の目標は、長期的な報酬を最大化する行動方針（ポリシー）を学習することである。", "3.強化学習は、教師あり学習と異なり、学習には事前にラベル付けされたデータが必要である。", "4.強化学習では、探索と利用のバランスを取る必要がなく、常に最良の既知の行動を選択すればよい。"], answer: 1, explanation: "強化学習は、報酬を最大化する最適な行動方針を学習することを目的としています。" },
        { question: "次のうち、「ディープラーニングにおける過学習（オーバーフィッティング）」に関する説明として誤っているものを1つ選びなさい。", options: ["1.過学習は、モデルが訓練データに過度に適応し、未知のデータに対しては性能が低下する現象である。", "2.ドロップアウトは、過学習を防ぐための手法の一つで、訓練時にランダムに一部のノードを無効化する。", "3.過学習が発生する原因の一つとして、訓練データの量が少ないことが挙げられる。", "4.過学習を防ぐためには、隠れ層の数を増やし、モデルの複雑さを高めることが効果的である。"], answer: 3, explanation: "隠れ層を増やしモデルを複雑にすると、過学習のリスクが高まります。" },
        { question: "次のうち、「クラスタリング」に関する説明として誤っているものを1つ選びなさい。", options: ["1.クラスタリングは、教師なし学習の一種であり、データを類似性に基づいてグループ分けする手法である。", "2.K-means法は、クラスタリングの代表的な手法の一つで、データポイントをK個のクラスタに分割する。", "3.クラスタリングの結果は、クラスタの数を変更しても必ず同じになるため、一度の計算で十分である。", "4.階層的クラスタリングは、データポイント間の距離を基に、段階的にクラスタを形成していく手法である。"], answer: 2, explanation: "クラスタリングの結果は、クラスタ数や初期値によって変動することがあります。" },
        { question: "次のうち、「ニューラルネットワーク」に関する説明として正しいものを1つ選びなさい。", options: ["1.ニューラルネットワークは、全てのノードが互いに接続されているため、計算コストが常に一定である。", "2.ニューラルネットワークの隠れ層の数を増やすと、必ずしもモデルの性能が向上するわけではない。", "3.ニューラルネットワークは、線形回帰モデルと同じ手法を用いて訓練される。", "4.ニューラルネットワークの出力層は、必ずソフトマックス関数を使用して確率分布を計算する。"], answer: 1, explanation: "隠れ層を増やしすぎると、過学習を起こし、モデルの性能が低下する場合があります。" },
        { question: "「AI利活用原則」に関する説明として誤っているものを1つ選びなさい。", options: ["1.AI利活用原則には、プライバシーの保護が含まれており、AIが扱うデータの収集と利用には厳格なルールが求められる。", "2.AI利活用原則の一つに、透明性の原則があり、AIシステムの意思決定プロセスが明確に説明されることが重要とされている。", "3.AI利活用原則では、AIの自己学習能力を制限し、人間による管理を前提とすることが推奨されている。", "4.AI利活用原則には、公平性の確保が含まれており、AIシステムが特定の集団に対して偏りなく公正に運用されることが求められている。"], answer: 2, explanation: "AI利活用原則に「AIの自己学習能力を制限する」という項目はありません。" },
        { question: "「強化学習」におけるエージェントの学習方法に関する説明として正しいものを1つ選びなさい。", options: ["1. 強化学習では、エージェントがすべての行動に対して即座に正解を教えられる。", "2. エージェントは、環境から得られる報酬を基にして、最適な行動を選択するように学習する。", "3. 強化学習では、すべての行動が同等の報酬を与えられるため、エージェントは常に同じ行動を取る。", "4. エージェントは、未来の行動による報酬を一切考慮せず、現在の報酬だけに基づいて行動を決定する。"], answer: 1, explanation: "強化学習は、エージェントが報酬を最大化するように行動を学習する手法です。" },
        { question: "「転移学習」に関する説明として誤っているものを1つ選びなさい。", options: ["1.転移学習は、あるタスクで訓練されたモデルを別のタスクに適用することができる。", "2. 転移学習は、特定のタスクに対して完全に新しいモデルをゼロから訓練する必要がない。", "3. 転移学習は、大量のデータを使ったモデルでなければ効果を発揮しない。", "4. 転移学習は、元のタスクで学習した知識を新しいタスクに応用するため、少量のデータでも高精度な結果が得られることが多い。"], answer: 2, explanation: "転移学習は、データが少ない場合でも高い効果を発揮します。" },
        { question: "「教師なし学習」に関する説明として正しいものを1つ選びなさい。", options: ["1.教師なし学習では、ラベル付きデータを使ってモデルを訓練し、予測精度を向上させる。", "2. 教師なし学習は、主にラベルなしデータを使用して、データのパターンや構造を発見する手法である。", "3. 教師なし学習は、常に事前に正解ラベルが与えられたデータに基づいている。", "4. 教師なし学習は、すべてのデータをランダムに分類するため、特定のパターンを見つけることはできない。"], answer: 1, explanation: "教師なし学習は、ラベルなしデータを用いてデータの構造やパターンを分析する手法です。" },
        { question: "「次元削減技術」に関する説明として誤っているものを1つ選びなさい。", options: ["1.次元削減は、データセットの特徴量の数を減らすことで、計算効率を向上させる手法である。", "2. 主成分分析(PCA)は、データの分散を最大化する方向に特徴量を変換して次元を削減する。", "3. 次元削減を行うと、すべての情報が失われるため、モデルの性能は必ず低下する。", "4. 次元削減は、過学習を防ぐために利用されることがある。"], answer: 2, explanation: "次元削減は、重要な情報をできるだけ保持しつつ、不要な情報を削減する手法です。" },
        { question: "「過学習」に関する説明として誤っているものを1つ選びなさい。", options: ["1. 過学習は、モデルが訓練データに過度に適応し、未知のデータに対しては性能が低下する現象である。", "2. 過学習を防ぐために、ドロップアウトや正則化などの手法が使用される。", "3. 過学習は、訓練データが十分に多ければ発生しないため、常にデータを増やすことが推奨される。", "4. 過学習が発生すると、モデルはノイズや無関係なパターンを学習し、汎化性能が低下する。"], answer: 2, explanation: "訓練データが多ければ過学習は起こりにくくなりますが、完全に防げるわけではありません。" },
        { question: "「リカレントニューラルネットワーク (RNN)」に関する説明として誤っているものを1つ選びなさい。", options: ["1. RNNは、シーケンスデータの各ステップで過去の情報を考慮して次のステップを予測する。", "2. RNNは、長期的な依存関係を学習するのが得意であり、勾配消失問題が発生しない。", "3. RNNは、自然言語処理や時系列データの解析に広く用いられている。", "4. LSTMやGRUは、RNNの勾配消失問題を解決するために開発されたモデルである。"], answer: 1, explanation: "RNNは長期的な依存関係の学習が苦手であり、勾配消失問題に悩まされます。" },
        { question: "「転移学習」に関する説明として正しいものを1つ選びなさい。", options: ["1. 転移学習は、元のタスクで訓練されたモデルの知識を、新しいタスクに再利用することができる手法である。", "2. 転移学習は、同じデータセットで異なるモデルをゼロから訓練することを目的としている。", "3. 転移学習は、データが多いときに効果を発揮し、データが少ない場合はあまり効果がない。", "4. 転移学習は、他のモデルから学んだ知識を利用しないため、常に完全に新しいデータが必要となる。"], answer: 0, explanation: "転移学習は、事前学習済みのモデルを新しいタスクに再利用する手法です。" }
      ],
      "第2章 生成AI": [
        { question: "次のうち、「生成AI (ジェネレーティブAI)」に関する説明として適切でないものを1つ選びなさい。", options: ["1.生成AIは新しいデータを生成するために、既存のデータパターンを学習する。", "2.生成AIにはGANやVAEなどのモデルが含まれる。", "3.生成AIは主に画像や音声の生成に使用され、テキストの生成には適用されない。", "4.Transformerモデルは、生成AIの一種であり、テキスト生成に優れた性能を持つ。"], answer: 2, explanation: "生成AIはテキスト生成にも広く活用されています。" },
        { question: "次のうち、「生成AI (ジェネレーティブAI)」の仕組みに関する説明として正しいものを1つ選びなさい。", options: ["1.GAN(敵対的生成ネットワーク)は、二つのモデルが協力して新しいデータを生成する手法である。", "2.VAE(変分自己符号化器)は、生成されるデータの潜在ベクトルを固定しておくことで、より多様なデータを生成することができる。", "3.Transformerモデルは、主にシーケンスデータを扱う際に使用されるが、その内部にリカレント層を持つため、処理速度が遅くなる傾向がある。", "4.自己回帰モデルは、出力される値が次の入力に依存するため、時系列データの生成に適している。"], answer: 3, explanation: "自己回帰モデルは、前の出力が次の入力となる性質から、時系列データやテキスト生成に適しています。" },
        { question: "「Transformerモデル」に関する説明として誤っているものを1つ選びなさい。", options: ["1.Transformerモデルは、並列処理が可能であり、従来のRNNよりも効率的にシーケンスデータを処理できる。", "2.TransformerモデルのAttention機構は、入力シーケンス全体にわたって関連性の高い部分に重点を置いて処理を行う。", "3.Transformerモデルは、リカレント層を使用しているため、長いシーケンスの処理に時間がかかる。", "4.Transformerモデルは、自然言語処理の分野で高い性能を発揮し、多くの言語モデルで採用されている。"], answer: 2, explanation: "Transformerモデルはリカレント層を使用せず、Attention機構によって並列処理が可能です。" },
        { question: "「自然言語処理(NLP)」に関する説明として正しいものを1つ選びなさい。", options: ["1.自然言語処理は、テキストデータの処理に特化しており、音声や画像データの処理には適用されない。", "2.NLPでは、テキストの単語順序を無視して解析を行うため、文の意味を完全に理解することはできない。", "3.トークナイゼーションは、テキストを単語や文などの単位に分割する自然言語処理の基本的な手法である。", "4.自然言語処理のモデルは、言語ごとに完全に異なる手法で訓練される必要があるため、汎用的なモデルは存在しない。"], answer: 2, explanation: "トークナイゼーションは、NLPにおける前処理の重要なステップです。" },
        { question: "「生成AIモデルのハルシネーション(幻覚)」に関する説明として誤っているものを1つ選びなさい。", options: ["1. ハルシネーションは、生成AIモデルが実際には存在しない情報を出力する現象である。", "2. ハルシネーションは、モデルが未学習のデータに対して推測を行った結果、誤った情報を生成することが原因である。", "3. ハルシネーションが発生するのは、主に音声認識モデルに限定されており、テキスト生成モデルでは起こらない。", "4. ハルシネーションを減らすためには、より多様で高品質なデータを用いたモデルの訓練が有効である。"], answer: 2, explanation: "ハルシネーションはテキスト生成モデルでも頻繁に発生します。" },
        { question: "「GAN(敵対的生成ネットワーク)」に関する説明として正しいものを1つ選びなさい。", options: ["1. GANは、一つのニューラルネットワークを用いてデータを生成し、別のモデルと競合することなく学習を進める。", "2. GANは、生成器と識別器の二つのモデルが競合することで、生成されるデータの品質を向上させる。", "3. GANは、生成器のみが学習を行い、識別器は事前に固定されたパラメータを使用する。", "4. GANは、生成器が作成したデータをすべて正解としてラベル付けし、識別器を訓練する。"], answer: 1, explanation: "GANは、生成器と識別器が互いに競い合いながら学習を進めることで、より高品質なデータを生成します。" },
        { question: "「半教師あり学習」に関する説明として誤っているものを1つ選びなさい。", options: ["1.半教師あり学習は、少量のラベル付きデータと大量のラベルなしデータを組み合わせてモデルを訓練する手法である。", "2. 半教師あり学習は、すべてのデータにラベルを付与する必要がないため、コストを削減できる。", "3. 半教師あり学習では、ラベル付きデータのみに基づいてモデルを訓練し、ラベルなしデータは利用しない。", "4. 半教師あり学習は、教師あり学習と教師なし学習の両方の手法を組み合わせたアプローチである。"], answer: 2, explanation: "半教師あり学習は、ラベルなしデータも活用してモデルを訓練します。" },
        { question: "「RNN（リカレントニューラルネットワーク）」に関する説明として誤っているものを1つ選びなさい。", options: ["1.RNNは、シーケンスデータの各要素を順番に処理し、過去の情報を考慮しながら出力を生成する。", "2. RNNは、バックプロパゲーションによって訓練されるが、勾配消失問題が発生しやすい。", "3. RNNは、長期的な依存関係を学習するのに適しているため、LSTMやGRUはほとんど使われない。", "4. RNNは、時系列データや自然言語処理のタスクで広く使用されている。"], answer: 2, explanation: "RNNは長期的な依存関係の学習が苦手であり、その問題を解決するためにLSTMやGRUが開発されました。" },
        { question: "「データ拡張」に関する説明として正しいものを1つ選びなさい。", options: ["1. データ拡張は、モデルの過学習を促進するため、通常は避けるべき手法である。", "2. データ拡張は、既存のデータセットに新たなサンプルを合成することで、訓練データのバリエーションを増やし、モデルの汎化性能を向上させる手法である。", "3. データ拡張は、ラベルなしデータのみに適用され、ラベル付きデータには効果がない。", "4. データ拡張によって作成された新たなサンプルは、元のデータセットに含まれていない場合、訓練には使用できない。"], answer: 1, explanation: "データ拡張は、訓練データの多様性を高め、モデルの汎化性能を向上させるために使用されます。" },
        { question: "「Attention機構」に関する説明として正しいものを1つ選びなさい。", options: ["1.Attention機構は、シーケンス全体の情報を均等に重み付けして処理を行う手法である。", "2. Attention機構は、入力シーケンスの中で重要な部分に焦点を当てて重み付けを行い、より関連性の高い情報を強調する手法である。", "3. Attention機構は、主に画像データの処理に特化しており、テキストデータの処理には適用されない。", "4. Attention機構を用いると、モデルの訓練が不安定になるため、自然言語処理では避けるべきである。"], answer: 1, explanation: "Attention機構は、入力シーケンス内で重要な部分に注目して処理を行う仕組みです。" },
        { question: "「CNN（畳み込みニューラルネットワーク）」に関する説明として正しいものを1つ選びなさい。", options: ["1. CNNは、すべての層が全結合層で構成されているため、画像認識には向いていない。", "2. CNNの畳み込み層は、画像の空間的関係を保持しながら特徴を抽出する役割を持つ。", "3. CNNは、入力データに依存せず、すべての種類のデータに対して同じ重みを適用する。", "4. CNNでは、プーリング層を使わずに常にフルサイズの画像データを処理することが推奨される。"], answer: 1, explanation: "CNNの畳み込み層は、画像の特徴を抽出するのに重要な役割を果たします。" },
        { question: "「生成AIモデルによるテキスト生成」に関する説明として誤っているものを1つ選びなさい。", options: ["1. テキスト生成モデルは、自然言語処理に基づいて、入力されたコンテキストに応じた文章を生成する。", "2. 大規模言語モデル（LLM）は、膨大なデータセットを使って事前に訓練され、その後、特定のタスクに応じて微調整されることが多い。", "3. テキスト生成AIは、最新のニュースや事実に基づいた正確な情報を常に提供する。", "4. モデルのトレーニングデータに依存するため、生成AIが不正確な情報やバイアスを含むテキストを生成するリスクがある。"], answer: 2, explanation: "生成AIは、学習データに基づいて情報を生成するため、常に最新で正確な情報を提供できるとは限りません。" },
        { question: "「データの次元削減」に関する説明として正しいものを1つ選びなさい。", options: ["1. 次元削減は、データの特徴量を増やすことで、より複雑なモデルを構築するための手法である。", "2. 主成分分析（PCA）は、データの分散を最大化する新しい軸を見つけて、次元を削減する手法の一つである。", "3. 次元削減を行うと、常にモデルの性能が低下するため、基本的に使用すべきではない。", "4. 次元削減は、すべてのデータの特徴量をランダムに削除することで、データ量を削減する手法である。"], answer: 1, explanation: "主成分分析（PCA）は、データの持つ情報をできるだけ保持しつつ、次元を削減する手法です。" },
        { question: "「生成AIによる音楽生成」に関する説明として正しいものを1つ選びなさい。", options: ["1.生成AIは、音楽データをテキストデータと同様に処理し、単純なアルゴリズムで音楽を生成する。", "2. 音楽生成AIは、過去の音楽パターンを学習し、新たな音楽作品を生成するが、既存の作曲技術は反映されない。", "3. 生成AIは、音楽のスタイルやテンポ、楽器の種類など、ユーザーの指定に基づいて音楽を自動生成できる。", "4. 音楽生成AIは、作成された楽曲がすべて既存の作品に似ているため、独自性を持たせることは不可能である。"], answer: 2, explanation: "生成AIは、ユーザーの指定に応じて多様な音楽を生成できます。" },
        { question: "「GAN（敵対的生成ネットワーク）」における生成器と識別器の役割について誤っているものを1つ選びなさい。", options: ["1. 生成器は、ノイズを入力として現実のようなデータを生成するモデルである。", "2. 識別器は、生成器が作成したデータと実際のデータを区別しようとするモデルである。", "3. 生成器は、識別器を訓練し、より正確にデータを分類できるようにする役割を持つ。", "4. GANは、生成器と識別器が互いに競い合うことで、生成されるデータの品質を向上させる。"], answer: 2, explanation: "生成器は識別器を騙すようにデータを生成し、識別器は生成器が生成したデータを見破るように学習します。" },
        { question: "「Transformerモデル」に関する説明として正しいものを1つ選びなさい。", options: ["1. Transformerモデルは、リカレント構造を持ち、シーケンスデータの長期的依存関係を学習する。", "2. Transformerモデルは、自己注意機構（Self-Attention）を利用して、シーケンス内の異なる部分の相互関係を考慮する。", "3. Transformerモデルは、時系列データの解析には適さないため、自然言語処理以外には使用されない。", "4. Transformerモデルは、複数の層を用いてデータを処理するが、出力層ではシーケンス全体の情報を無視する。"], answer: 1, explanation: "Transformerモデルは、自己注意機構（Self-Attention）を利用して、シーケンス全体の情報を効率的に処理します。" },
        { question: "「LSTM（長・短期記憶）」に関する説明として正しいものを1つ選びなさい。", options: ["1. LSTMは、RNNと同じ構造を持ち、特に短期的な依存関係の学習に優れている。", "2. LSTMは、ゲート構造を持ち、過去の情報を保持しながら長期的な依存関係を学習できる。", "3. LSTMは、勾配消失問題を防ぐために、リカレント接続を削除している。", "4. LSTMは、固定された時間間隔でしかデータを処理できないため、変動するシーケンスデータには適さない。"], answer: 1, explanation: "LSTMは、ゲート構造により過去の情報を選択的に保持・忘却することで、長期的な依存関係を学習できます。" },
        { question: "「過学習」に関する説明として誤っているものを1つ選びなさい。", options: ["1. 過学習は、モデルが訓練データに過度に適応し、未知のデータに対しては性能が低下する現象である。", "2. 過学習を防ぐために、ドロップアウトや正則化などの手法が使用される。", "3. 過学習は、訓練データが十分に多ければ発生しないため、常にデータを増やすことが推奨される。", "4. 過学習が発生すると、モデルはノイズや無関係なパターンを学習し、汎化性能が低下する。"], answer: 2, explanation: "訓練データが多ければ過学習は起こりにくくなりますが、完全に防げるわけではありません。" },
        { question: "「AIによる画像認識技術」に関する説明として誤っているものを1つ選びなさい。", options: ["1. 画像認識技術では、畳み込みニューラルネットワーク（CNN）が広く使用されている。", "2. CNNは、画像データの空間的構造を保持しながら特徴を抽出することに優れている。", "3. 画像認識モデルは、訓練データと異なる視点や角度の画像には適用できない。", "4. データ拡張技術を用いることで、訓練データのバリエーションを増やし、画像認識モデルの汎化性能を向上させることができる。"], answer: 2, explanation: "画像認識モデルは、未知のデータにも適用できるように汎化性能を高めることが重要です。" },
        { question: "「生成AIによる画像生成」に関する説明として誤っているものを1つ選びなさい。", options: ["1. 生成AIは、過去の画像データを学習し、新しい画像を生成するために使用される。", "2. GAN（敵対的生成ネットワーク）は、生成器と識別器が互いに競合することでリアルな画像を生成する。", "3. 生成AIが生成する画像は、常に実際の写真と区別がつきやすいため、悪用されるリスクは少ない。", "4. 生成AIは、ユーザーが指定したスタイルや特徴に基づいて、新しい画像を生成することができる。"], answer: 2, explanation: "生成AIによる画像は非常にリアルで、本物の写真と区別がつきにくいため、悪用リスクがあります。" },
        { question: "「Attention機構」に関する説明として誤っていものを1つ選びなさい。", options: ["1. Attention機構は、シーケンス全体を一様に重視するのではなく、重要な部分に焦点を当てて重み付けを行う。", "2. Attention機構は、自然言語処理だけでなく、画像処理や音声処理など他のタスクにも応用されている。", "3. Transformerモデルでは、Attention機構を利用して長いシーケンス内の依存関係を効率的に学習する。", "4. Attention機構は、入力データの全体を無視し、特定の部分だけに焦点を当てて処理を行う。"], answer: 3, explanation: "Attention機構は、入力データ全体を考慮した上で、重要な部分に重み付けを行います。" }
      ],
      "第3章 生成AIの動向": [
        { question: "次のうち、「ディープフェイク技術」に関する説明として正しいものを1つ選びなさい。", options: ["1.ディープフェイク技術は、従来のビデオ編集ソフトウェアを使用して作成されるため、高度なAI技術を必要としない。", "2.ディープフェイクは、AIによって生成された音声や映像を本物と区別することが非常に困難になることがある。", "3.ディープフェイク技術の進歩により、現在ではディープフェイクを作成する際に膨大なデータや時間は必要なくなった。", "4.ディープフェイクは、主にエンターテイメントやゲームの分野でのみ利用され、他の分野での影響は限定的である。"], answer: 1, explanation: "AIによって生成されたコンテンツは、真実と見分けるのが難しい場合があります。" },
        { question: "次のうち、「生成AIにおける注意事項」として誤っているものを1つ選びなさい。", options: ["1.生成AIによって作成されたコンテンツには著作権が発生しないため、自由に使用することができる。", "2.生成AIは、訓練データに偏りがある場合、生成されるコンテンツにも偏りが反映される可能性がある。", "3.生成AIが作成したコンテンツは、著作権侵害や肖像権侵害のリスクがあるため、適切な管理が求められる。", "4.生成AIによるフェイクコンテンツの拡散は、社会的な混乱を引き起こす可能性があるため、注意が必要である。"], answer: 0, explanation: "生成AIによって作成されたコンテンツにも著作権が発生する場合があります。" },
        { question: "「生成AIによるフェイクコンテンツ」に関する説明として正しいものを1つ選びなさい。", options: ["1.生成AIによるフェイクコンテンツは、技術的に簡単に見分けることができるため、社会的な影響は少ない。", "2.生成AIが作成したフェイクコンテンツは、拡散される前に常にAIによって自動的に検出される。", "3.生成AIによるフェイクコンテンツは、真実の情報と区別が難しい場合があり、社会的混乱や誤情報の拡散につながる可能性がある。", "4.生成AIによるフェイクコンテンツは、エンターテイメント分野に限定して使用され、他の分野には影響を与えない。"], answer: 2, explanation: "生成AIによるフェイクコンテンツは、誤情報拡散のリスクを伴います。" },
        { question: "「ディープフェイク技術」に関する説明として誤っているものを1つ選びなさい。", options: ["1. ディープフェイク技術は、画像や映像において特定の人物の顔を別の顔に置き換えることができる。", "2. ディープフェイクは、主に敵対的生成ネットワーク(GAN)を利用して生成される。", "3. ディープフェイク技術は悪用されることがなく、セキュリティやプライバシーへの影響は少ない。", "4. ディープフェイク技術が進化すると、本物の映像と偽の映像を区別することが非常に難しくなる場合がある。"], answer: 2, explanation: "ディープフェイク技術は悪用されるリスクがあり、セキュリティやプライバシーに大きな影響を与えます。" }
      ],
      "第4章 情報リテラシー・基本理念とAI社会原則": [
        { question: "次のうち、「セキュリティとプライバシー」に関する説明として誤っているものを1つ選びなさい。", options: ["1.フィッシング詐欺は、インターネット利用者を騙し、個人情報を盗むために行われる詐欺の一種である。", "2.スミッシングは、メールを通じて送信された悪意のあるリンクをクリックさせることで、個人情報を取得しようとする攻撃手法である。", "3.QRコードを悪用した攻撃では、偽のQRコードを使用してユーザーを悪意のあるウェブサイトに誘導することができる。", "4.ソーシャルエンジニアリング攻撃は、人間の心理的な弱点をついて情報を引き出す手法であり、インターネットに限定された攻撃ではない。"], answer: 1, explanation: "スミッシングはSMS（ショートメッセージサービス）を利用した詐欺です。" },
        { question: "次のうち、「AIの倫理的課題」に関する説明として誤っているものを1つ選びなさい。", options: ["1.AIシステムが導入されることで、従来の労働市場が変動し、職業の自動化により失業リスクが増加する可能性がある。", "2.AIの意思決定プロセスがブラックボックス化することで、責任の所在が不明確になる懸念がある。", "3.AIはプライバシー保護の観点から、個人情報を収集する際に事前の許可が不要とされる。", "4.バイアスのあるデータで訓練されたAIは、特定の人種や性別に対する差別的な結果を生む可能性がある。"], answer: 2, explanation: "個人情報の収集には、事前の許可や同意が原則として必要です。" },
        { question: "「AI社会原則」に関する説明として誤っているものを1つ選びなさい。", options: ["1.AI社会原則では、AIシステムの開発と使用において公平性や透明性が求められている。", "2. AI社会原則は、AI技術が進歩する中で、プライバシーやセキュリティに対する保護が不要になることを想定している。", "3. AI社会原則の一つには、AIシステムの透明性を確保し、意思決定の過程を説明可能にすることが含まれている。", "4. AIの開発においては、人間中心のアプローチを取り、人間の尊厳や自律性を尊重することが求められている。"], answer: 1, explanation: "AI社会原則は、AIの発展に伴い、プライバシーやセキュリティ保護の重要性が増すことを想定しています。" },
        { question: "「AIとプライバシー」に関する説明として誤っているものを1つ選びなさい。", options: ["1. AIは大量のデータを利用して学習するため、個人情報が含まれるデータの扱いには特別な配慮が必要である。", "2. AIシステムが学習する際に利用するデータは、すべて匿名化されているため、プライバシーの侵害は発生しない。", "3. 個人情報保護法では、AIが利用するデータにもプライバシー保護に関する規制が適用される。", "4. AIによるデータ分析では、個人を特定できないように処理を施す匿名加工情報が推奨される場合がある。"], answer: 1, explanation: "AIの学習データが必ずしもすべて匿名化されているわけではありません。" },
        { question: "「サイバーセキュリティ」に関する説明として正しいものを1つ選びなさい。", options: ["1. サイバーセキュリティは、主に物理的なセキュリティ対策に依存しており、ソフトウェアの安全性は重視されない。", "2. サイバーセキュリティは、情報システムやネットワークを保護し、データの機密性、完全性、可用性を確保するための技術である。", "3. サイバーセキュリティ対策を施すと、完全にサイバー攻撃のリスクを排除することができる。", "4. サイバーセキュリティは、ネットワーク上の脅威に対してのみ適用され、クラウド環境には適用されない。"], answer: 1, explanation: "サイバーセキュリティは、情報システムの安全性を確保するための重要な技術です。" },
        { question: "「AIに関する透明性と説明責任」に関する説明として正しいものを1つ選びなさい。", options: ["1. AIシステムは常に透明性が保証されており、すべてのプロセスが完全に理解可能である。", "2. 説明責任を果たすためには、AIシステムがどのようなデータに基づいて意思決定を行ったのかを説明できる必要がある。", "3. AIの透明性を高めると、モデルの性能が低下するため、実務での導入は推奨されない。", "4. AIの透明性は、技術者のみが理解すればよいため、一般ユーザーへの説明は不要である。"], answer: 1, explanation: "AIの説明責任を果たすためには、意思決定の根拠を明確にすることが求められます。" },
        { question: "「AIの公平性」に関する説明として誤っているものを1つ選びなさい。", options: ["1. AIシステムは、訓練データに含まれるバイアスを学習してしまい、特定のグループに対する不公平な結果を生む可能性がある。", "2. AIの公平性を確保するためには、データのバイアスを排除し、適切に多様なデータセットを使用することが重要である。", "3. AIは数学的に公平であるため、バイアスの影響を受けることはない。", "4. AIシステムの設計時には、社会的な公平性や倫理的な配慮が必要である。"], answer: 2, explanation: "AIは訓練データに含まれるバイアスを学習するため、不公平な結果を生み出す可能性があります。" },
        { question: "「インターネットリテラシー」に関する説明として正しいものを1つ選びなさい。", options: ["1. インターネットリテラシーは、主に技術的スキルに依存し、情報の正確さや信頼性は考慮されない。", "2. インターネットリテラシーを高めることは、オンラインでのセキュリティやプライバシー保護に役立つ。", "3. インターネットリテラシーは、インターネットの利用に限定され、情報リテラシーとは無関係である。", "4. インターネットリテラシーが高ければ、フィッシング詐欺のリスクは完全に排除できる。"], answer: 1, explanation: "インターネットリテラシーには、情報の信頼性を判断する能力やセキュリティ対策の知識が含まれます。" },
        { question: "「個人情報保護法」に関する説明として正しいものを1つ選びなさい。", options: ["1. 個人情報保護法では、すべてのデータが個人情報として扱われるため、公開されている情報も含めて保護の対象である。", "2. 個人識別符号は、特定の個人を直接識別できる情報であり、これも個人情報保護法の対象となる。", "3. 匿名加工情報は、個人を特定できるため、同意なしに自由に利用することは許されない。", "4. 改正個人情報保護法では、要配慮個人情報に対してのみ特別な保護が求められる。"], answer: 1, explanation: "個人識別符号は、個人情報保護法の保護対象となる「個人情報」に含まれます。" }
      ],
      "第5章 テキスト生成AIのプロンプト制作と実例": [
        { question: "「シンギュラリティ（技術的特異点）」に関する説明として誤っているものを1つ選びなさい。", options: ["1.シンギュラリティは、AIが人間の知能を超える技術的特異点のことであり、将来のある時点で到来する可能性があるとされている。", "2.シンギュラリティに達すると、AIは自己改善を繰り返し、人間が予測不能な形で進化を遂げるとされている。", "3.シンギュラリティは、ヴァーナー・ヴィンジやレイ・カーツワイルによって提唱された概念である。", "4.シンギュラリティが到来すると、AIの進化は人間の制御下に留まり、完全に予測可能な結果を生むとされている。"], answer: 3, explanation: "シンギュラリティは、AIの進化が人間の制御を離れ、予測不能な変化をもたらすとされています。" },
        { question: "「ノーフリーランチ定理」に関する説明として正しいものを1つ選びなさい。", options: ["1. ノーフリーランチ定理は、あるアルゴリズムが全ての問題において最適な性能を発揮することを示している。", "2. ノーフリーランチ定理は、アルゴリズムの性能が特定の問題においてのみ有効であり、全ての問題に対して均一に効果的ではないことを示している。", "3. ノーフリーランチ定理は、最適なアルゴリズムを選択すれば、問題の種類に関わらず常に最高の結果を得られると述べている。", "4. ノーフリーランチ定理は、どのアルゴリズムもデータの種類に関係なく、同等の結果をもたらすことを示している。"], answer: 1, explanation: "ノーフリーランチ定理は、あるアルゴリズムが万能ではないことを示しています。" }
      ],
      "模擬試験60問": [
        { question: "次のうち、「生成AI (ジェネレーティブAI)」に関する説明として適切でないものを1つ選びなさい。", options: ["1.生成AIは新しいデータを生成するために、既存のデータパターンを学習する。", "2.生成AIにはGANやVAEなどのモデルが含まれる。", "3.生成AIは主に画像や音声の生成に使用され、テキストの生成には適用されない。", "4.Transformerモデルは、生成AIの一種であり、テキスト生成に優れた性能を持つ。"], answer: 2, explanation: "生成AIはテキスト生成にも広く活用されています。" },
        { question: "次のうち、「教師なし学習」に関する説明として誤っているものを1つ選びなさい。", options: ["1.教師なし学習では、ラベルの付いていないデータを用いてモデルをトレーニングし、データの構造やパターンを発見する。", "2.教師なし学習の代表的な手法には、クラスタリングや次元削減が含まれる。", "3.教師なし学習では、モデルは与えられた正解に基づいてフィードバックを受け、予測精度を向上させる。", "4.教師なし学習は、データの分類や特徴量の抽出など、さまざまなタスクに応用される。"], answer: 2, explanation: "「正解に基づくフィードバック」は教師あり学習の特徴です。" },
        { question: "次のうち、「AIの歴史」に関する説明として誤っているものを1つ選びなさい。", options: ["1.第一次AIブームは、主に探索と推論の技術を中心に発展した。", "2.第二次AIブームでは、エキスパートシステムが広く利用されるようになったが、ブームは終息し「AIの冬」と呼ばれる時期が訪れた。", "3.第三次AIブームは、ビッグデータの活用とディープラーニングの発展によって引き起こされた。", "4.第三次AIブーム以降、AIは特に金融業界にのみ限定して応用されている。"], answer: 3, explanation: "AIは金融業界だけでなく、医療、製造、交通など多岐にわたる分野で応用されています。" },
        { question: "次のうち、「生成AI (ジェネレーティブAI)」の仕組みに関する説明として正しいものを1つ選びなさい。", options: ["1.GAN(敵対的生成ネットワーク)は、二つのモデルが協力して新しいデータを生成する手法である。", "2.VAE(変分自己符号化器)は、生成されるデータの潜在ベクトルを固定しておくことで、より多様なデータを生成することができる。", "3.Transformerモデルは、主にシーケンスデータを扱う際に使用されるが、その内部にリカレント層を持つため、処理速度が遅くなる傾向がある。", "4.自己回帰モデルは、出力される値が次の入力に依存するため、時系列データの生成に適している。"], answer: 3, explanation: "自己回帰モデルは、前の出力が次の入力となる性質から、時系列データやテキスト生成に適しています。" },
        { question: "次のうち、「セキュリティとプライバシー」に関する説明として誤っているものを1つ選びなさい。", options: ["1.フィッシング詐欺は、インターネット利用者を騙し、個人情報を盗むために行われる詐欺の一種である。", "2.スミッシングは、メールを通じて送信された悪意のあるリンクをクリックさせることで、個人情報を取得しようとする攻撃手法である。", "3.QRコードを悪用した攻撃では、偽のQRコードを使用してユーザーを悪意のあるウェブサイトに誘導することができる。", "4.ソーシャルエンジニアリング攻撃は、人間の心理的な弱点をついて情報を引き出す手法であり、インターネットに限定された攻撃ではない。"], answer: 1, explanation: "スミッシングはSMS（ショートメッセージサービス）を利用した詐欺です。" },
        { question: "次のうち、「転移学習」に関する説明として正しいものを1つ選びなさい。", options: ["1.転移学習は、モデルを一から再学習させる手法であり、既存のモデルや知識は使用しない。", "2.転移学習は、ある特定のタスクで学習したモデルを、別の関連するタスクに適用することで、学習効率を向上させる手法である。", "3.転移学習は、通常、新しいデータセットが非常に大規模である場合にのみ効果を発揮する。", "4.転移学習を用いると、過学習のリスクが常に増加する。"], answer: 1, explanation: "転移学習は、既存の学習済みモデルを活用し、新しいタスクの学習効率を向上させます。" },
        { question: "次のうち、「シンギュラリティ（技術的特異点）」に関する説明として誤っているものを1つ選びなさい。", options: ["1.シンギュラリティは、AIが人間の知能を超える技術的特異点のことであり、将来のある時点で到来する可能性があるとされている。", "2.シンギュラリティに達すると、AIは自己改善を繰り返し、人間が予測不能な形で進化を遂げるとされている。", "3.シンギュラリティは、ヴァーナー・ヴィンジやレイ・カーツワイルによって提唱された概念である。", "4.シンギュラリティが到来すると、AIの進化は人間の制御下に留まり、完全に予測可能な結果を生むとされている。"], answer: 3, explanation: "シンギュラリティは、AIの進化が人間の制御を離れ、予測不能な変化をもたらすとされています。" },
        { question: "次のうち、「生成AIにおける注意事項」として誤っているものを1つ選びなさい。", options: ["1.生成AIによって作成されたコンテンツには著作権が発生しないため、自由に使用することができる。", "2.生成AIは、訓練データに偏りがある場合、生成されるコンテンツにも偏りが反映される可能性がある。", "3.生成AIが作成したコンテンツは、著作権侵害や肖像権侵害のリスクがあるため、適切な管理が求められる。", "4.生成AIによるフェイクコンテンツの拡散は、社会的な混乱を引き起こす可能性があるため、注意が必要である。"], answer: 0, explanation: "生成AIによって作成されたコンテンツにも著作権が発生する場合があります。" },
        { question: "次のうち、「ニューラルネットワーク」に関する説明として正しいものを1つ選びなさい。", options: ["1.ニューラルネットワークは、全てのノードが互いに接続されているため、計算コストが常に一定である。", "2.ニューラルネットワークの隠れ層の数を増やすと、必ずしもモデルの性能が向上するわけではない。", "3.ニューラルネットワークは、線形回帰モデルと同じ手法を用いて訓練される。", "4.ニューラルネットワークの出力層は、必ずソフトマックス関数を使用して確率分布を計算する。"], answer: 1, explanation: "隠れ層を増やしすぎると、過学習を起こし、モデルの性能が低下する場合があります。" },
        { question: "「AI利活用原則」に関する説明として誤っているものを1つ選びなさい。", options: ["1.AI利活用原則には、プライバシーの保護が含まれており、AIが扱うデータの収集と利用には厳格なルールが求められる。", "2.AI利活用原則の一つに、透明性の原則があり、AIシステムの意思決定プロセスが明確に説明されることが重要とされている。", "3.AI利活用原則では、AIの自己学習能力を制限し、人間による管理を前提とすることが推奨されている。", "4.AI利活用原則には、公平性の確保が含まれており、AIシステムが特定の集団に対して偏りなく公正に運用されることが求められている。"], answer: 2, explanation: "AI利活用原則に「AIの自己学習能力を制限する」という項目はありません。" },
        { question: "「強化学習」に関する説明として正しいものを1つ選びなさい。", options: ["1.強化学習では、エージェントがすべての行動に対して即座に報酬を受け取る。", "2.強化学習の目標は、長期的な報酬を最大化する行動方針（ポリシー）を学習することである。", "3.強化学習は、教師あり学習と異なり、学習には事前にラベル付けされたデータが必要である。", "4.強化学習では、探索と利用のバランスを取る必要がなく、常に最良の既知の行動を選択すればよい。"], answer: 1, explanation: "強化学習は、報酬を最大化する最適な行動方針を学習することを目的としています。" },
        { question: "「ディープラーニングにおける過学習（オーバーフィッティング）」に関する説明として誤っているものを1つ選びなさい。", options: ["1.過学習は、モデルが訓練データに過度に適応し、未知のデータに対しては性能が低下する現象である。", "2.ドロップアウトは、過学習を防ぐための手法の一つで、訓練時にランダムに一部のノードを無効化する。", "3.過学習が発生する原因の一つとして、訓練データの量が少ないことが挙げられる。", "4.過学習を防ぐためには、隠れ層の数を増やし、モデルの複雑さを高めることが効果的である。"], answer: 3, explanation: "隠れ層を増やしモデルを複雑にすると、過学習のリスクが高まります。" },
        { question: "「Transformerモデル」に関する説明として誤っているものを1つ選びなさい。", options: ["1.Transformerモデルは、並列処理が可能であり、従来のRNNよりも効率的にシーケンスデータを処理できる。", "2.TransformerモデルのAttention機構は、入力シーケンス全体にわたって関連性の高い部分に重点を置いて処理を行う。", "3.Transformerモデルは、リカレント層を使用しているため、長いシーケンスの処理に時間がかかる。", "4.Transformerモデルは、自然言語処理の分野で高い性能を発揮し、多くの言語モデルで採用されている。"], answer: 2, explanation: "Transformerモデルはリカレント層を使用せず、Attention機構によって並列処理が可能です。" },
        { question: "「生成AIのビジネス応用」に関する説明として正しいものを1つ選びなさい。", options: ["1.生成AIは、ビジネスにおいて画像や動画の生成に特化しており、テキスト生成にはほとんど利用されない。", "2.生成AIを活用することで、アンケート項目の自動生成やデータの分析が効率化される。", "3.生成AIは、主にマーケティング分野で使用され、他の業務分野ではほとんど使用されない。", "4.生成AIを使って作成されたビジネス書類は、法的に有効とされることはない。"], answer: 1, explanation: "生成AIはテキスト生成にも活用され、ビジネス文書作成やアンケート作成などを効率化できます。" },
        { question: "「クラスタリング」に関する説明として誤っているものを1つ選びなさい。", options: ["1.クラスタリングは、教師なし学習の一種であり、データを類似性に基づいてグループ分けする手法である。", "2.K-means法は、クラスタリングの代表的な手法の一つで、データポイントをK個のクラスタに分割する。", "3.クラスタリングの結果は、クラスタの数を変更しても必ず同じになるため、一度の計算で十分である。", "4.階層的クラスタリングは、データポイント間の距離を基に、段階的にクラスタを形成していく手法である。"], answer: 2, explanation: "クラスタリングの結果は、クラスタ数や初期値によって変動することがあります。" },
        { question: "「自然言語処理（NLP）」に関する説明として正しいものを1つ選びなさい。", options: ["1.自然言語処理は、テキストデータの処理に特化しており、音声や画像データの処理には適用されない。", "2.NLPでは、テキストの単語順序を無視して解析を行うため、文の意味を完全に理解することはできない。", "3.トークナイゼーションは、テキストを単語や文などの単位に分割する自然言語処理の基本的な手法である。", "4.自然言語処理のモデルは、言語ごとに完全に異なる手法で訓練される必要があるため、汎用的なモデルは存在しない。"], answer: 2, explanation: "トークナイゼーションは、NLPにおける前処理の重要なステップです。" },
        { question: "「AIの倫理的課題」に関する説明として誤っているものを1つ選びなさい。", options: ["1.AIシステムが導入されることで、従来の労働市場が変動し、職業の自動化により失業リスクが増加する可能性がある。", "2.AIの意思決定プロセスがブラックボックス化することで、責任の所在が不明確になる懸念がある。", "3.AIはプライバシー保護の観点から、個人情報を収集する際に事前の許可が不要とされる。", "4.バイアスのあるデータで訓練されたAIは、特定の人種や性別に対する差別的な結果を生む可能性がある。"], answer: 2, explanation: "個人情報の収集には、事前の許可や同意が原則として必要です。" },
        { question: "「生成AIによるフェイクコンテンツ」に関する説明として正しいものを1つ選びなさい。", options: ["1.生成AIによるフェイクコンテンツは、技術的に簡単に見分けることができるため、社会的な影響は少ない。", "2.生成AIが作成したフェイクコンテンツは、拡散される前に常にAIによって自動的に検出される。", "3.生成AIによるフェイクコンテンツは、真実の情報と区別が難しい場合があり、社会的混乱や誤情報の拡散につながる可能性がある。", "4.生成AIによるフェイクコンテンツは、エンターテイメント分野に限定して使用され、他の分野には影響を与えない。"], answer: 2, explanation: "生成AIによるフェイクコンテンツは、誤情報拡散のリスクを伴います。" },
        { question: "「AIモデルのファインチューニング」に関する説明として誤っているものを1つ選びなさい。", options: ["1. ファインチューニングは、既存のAIモデルに新たなデータを追加して再訓練することで、特定のタスクに合わせてモデルの性能を向上させる手法である。", "2. ファインチューニングは、事前に学習されたモデルのすべての層を固定し、新しいデータで最後の出力層だけを訓練する。", "3. ファインチューニングは、新しいデータセットに合わせて学習率を調整することが重要であり、適切に行えばモデルの精度を大幅に向上させることができる。", "4. ファインチューニングは、転移学習の一種であり、既存のモデルに新たな知識を付加することで、特定の問題領域に適したモデルを作成する。"], answer: 1, explanation: "ファインチューニングでは、最後の出力層だけでなく、より多くの層を訓練し直すのが一般的です。" },
        { question: "「ノーフリーランチ定理」に関する説明として正しいものを1つ選びなさい。", options: ["1. ノーフリーランチ定理は、あるアルゴリズムが全ての問題において最適な性能を発揮することを示している。", "2. ノーフリーランチ定理は、アルゴリズムの性能が特定の問題においてのみ有効であり、全ての問題に対して均一に効果的ではないことを示している。", "3. ノーフリーランチ定理は、最適なアルゴリズムを選択すれば、問題の種類に関わらず常に最高の結果を得られると述べている。", "4. ノーフリーランチ定理は、どのアルゴリズムもデータの種類に関係なく、同等の結果をもたらすことを示している。"], answer: 1, explanation: "ノーフリーランチ定理は、あるアルゴリズムが万能ではないことを示しています。" },
        { question: "「AIによる画像認識技術」に関する説明として誤っているものを1つ選びなさい。", options: ["1. 画像認識技術では、畳み込みニューラルネットワーク（CNN）が広く使用されている。", "2. CNNは、画像データの空間的構造を保持しながら特徴を抽出することに優れている。", "3. 画像認識モデルは、訓練データと異なる視点や角度の画像には適用できない。", "4. データ拡張技術を用いることで、訓練データのバリエーションを増やし、画像認識モデルの汎化性能を向上させることができる。"], answer: 2, explanation: "画像認識モデルは、未知のデータにも適用できるように汎化性能を高めることが重要です。" },
        { question: "「LSTM（長・短期記憶）」に関する説明として正しいものを1つ選びなさい。", options: ["1. LSTMは、従来のRNNと異なり、長期的な依存関係を学習することができるが、短期的な依存関係は無視される。", "2. LSTMは、内部にゲート構造を持ち、過去の情報を選択的に保持または忘却することで、長期的な依存関係を学習できる。", "3. LSTMは、一般的にシーケンスデータの処理には適用されず、画像認識に特化している。", "4. LSTMは、訓練中に長期的な情報を完全に保持するため、勾配消失問題が起こりやすい。"], answer: 1, explanation: "LSTMは、ゲート構造により長期的な依存関係を学習することができ、勾配消失問題を軽減します。" },
        { question: "「生成AIモデルのハルシネーション（幻覚）」に関する説明として誤っているものを1つ選びなさい。", options: ["1. ハルシネーションは、生成AIモデルが実際には存在しない情報を出力する現象である。", "2. ハルシネーションは、モデルが未学習のデータに対して推測を行った結果、誤った情報を生成することが原因である。", "3. ハルシネーションが発生するのは、主に音声認識モデルに限定されており、テキスト生成モデルでは起こらない。", "4. ハルシネーションを減らすためには、より多様で高品質なデータを用いたモデルの訓練が有効である。"], answer: 2, explanation: "ハルシネーションはテキスト生成モデルでも頻繁に発生します。" },
        { question: "「GAN（敵対的生成ネットワーク）」に関する説明として正しいものを1つ選びなさい。", options: ["1. GANは、一つのニューラルネットワークを用いてデータを生成し、別のモデルと競合することなく学習を進める。", "2. GANは、生成器と識別器の二つのモデルが競合することで、生成されるデータの品質を向上させる。", "3. GANは、生成器のみが学習を行い、識別器は事前に固定されたパラメータを使用する。", "4. GANは、生成器が作成したデータをすべて正解としてラベル付けし、識別器を訓練する。"], answer: 1, explanation: "GANは、生成器と識別器が互いに競い合いながら学習を進めることで、より高品質なデータを生成します。" },
        { question: "「半教師あり学習」に関する説明として誤っているものを1つ選びなさい。", options: ["1.半教師あり学習は、少量のラベル付きデータと大量のラベルなしデータを組み合わせてモデルを訓練する手法である。", "2. 半教師あり学習は、すべてのデータにラベルを付与する必要がないため、コストを削減できる。", "3. 半教師あり学習では、ラベル付きデータのみに基づいてモデルを訓練し、ラベルなしデータは利用しない。", "4. 半教師あり学習は、教師あり学習と教師なし学習の両方の手法を組み合わせたアプローチである。"], answer: 2, explanation: "半教師あり学習は、ラベルなしデータも活用してモデルを訓練します。" },
        { question: "「RNN（リカレントニューラルネットワーク）」に関する説明として誤っているものを1つ選びなさい。", options: ["1.RNNは、シーケンスデータの各要素を順番に処理し、過去の情報を考慮しながら出力を生成する。", "2. RNNは、バックプロパゲーションによって訓練されるが、勾配消失問題が発生しやすい。", "3. RNNは、長期的な依存関係を学習するのに適しているため、LSTMやGRUはほとんど使われない。", "4. RNNは、時系列データや自然言語処理のタスクで広く使用されている。"], answer: 2, explanation: "RNNは長期的な依存関係の学習が苦手であり、その問題を解決するためにLSTMやGRUが開発されました。" },
        { question: "「データ拡張」に関する説明として正しいものを1つ選びなさい。", options: ["1. データ拡張は、モデルの過学習を促進するため、通常は避けるべき手法である。", "2. データ拡張は、既存のデータセットに新たなサンプルを合成することで、訓練データのバリエーションを増やし、モデルの汎化性能を向上させる手法である。", "3. データ拡張は、ラベルなしデータのみに適用され、ラベル付きデータには効果がない。", "4. データ拡張によって作成された新たなサンプルは、元のデータセットに含まれていない場合、訓練には使用できない。"], answer: 1, explanation: "データ拡張は、訓練データの多様性を高め、モデルの汎化性能を向上させるために使用されます。" },
        { question: "「Attention機構」に関する説明として正しいものを1つ選びなさい。", options: ["1.Attention機構は、シーケンス全体の情報を均等に重み付けして処理を行う手法である。", "2. Attention機構は、入力シーケンスの中で重要な部分に焦点を当てて重み付けを行い、より関連性の高い情報を強調する手法である。", "3. Attention機構は、主に画像データの処理に特化しており、テキストデータの処理には適用されない。", "4. Attention機構を用いると、モデルの訓練が不安定になるため、自然言語処理では避けるべきである。"], answer: 1, explanation: "Attention機構は、入力シーケンス内で重要な部分に注目して処理を行う仕組みです。" },
        { question: "「CNN（畳み込みニューラルネットワーク）」に関する説明として正しいものを1つ選びなさい。", options: ["1. CNNは、すべての層が全結合層で構成されているため、画像認識には向いていない。", "2. CNNの畳み込み層は、画像の空間的関係を保持しながら特徴を抽出する役割を持つ。", "3. CNNは、入力データに依存せず、すべての種類のデータに対して同じ重みを適用する。", "4. CNNでは、プーリング層を使わずに常にフルサイズの画像データを処理することが推奨される。"], answer: 1, explanation: "CNNの畳み込み層は、画像の特徴を抽出するのに重要な役割を果たします。" },
        { question: "「生成AIモデルによるテキスト生成」に関する説明として誤っているものを1つ選びなさい。", options: ["1. テキスト生成モデルは、自然言語処理に基づいて、入力されたコンテキストに応じた文章を生成する。", "2. 大規模言語モデル（LLM）は、膨大なデータセットを使って事前に訓練され、その後、特定のタスクに応じて微調整されることが多い。", "3. テキスト生成AIは、最新のニュースや事実に基づいた正確な情報を常に提供する。", "4. モデルのトレーニングデータに依存するため、生成AIが不正確な情報やバイアスを含むテキストを生成するリスクがある。"], answer: 2, explanation: "生成AIは、学習データに基づいて情報を生成するため、常に最新で正確な情報を提供できるとは限りません。" },
        { question: "「データの次元削減」に関する説明として正しいものを1つ選びなさい。", options: ["1. 次元削減は、データの特徴量を増やすことで、より複雑なモデルを構築するための手法である。", "2. 主成分分析（PCA）は、データの分散を最大化する新しい軸を見つけて、次元を削減する手法の一つである。", "3. 次元削減を行うと、常にモデルの性能が低下するため、基本的に使用すべきではない。", "4. 次元削減は、すべてのデータの特徴量をランダムに削除することで、データ量を削減する手法である。"], answer: 1, explanation: "主成分分析（PCA）は、データの持つ情報をできるだけ保持しつつ、次元を削減する手法です。" },
        { question: "「生成AIによる音楽生成」に関する説明として正しいものを1つ選びなさい。", options: ["1.生成AIは、音楽データをテキストデータと同様に処理し、単純なアルゴリズムで音楽を生成する。", "2. 音楽生成AIは、過去の音楽パターンを学習し、新たな音楽作品を生成するが、既存の作曲技術は反映されない。", "3. 生成AIは、音楽のスタイルやテンポ、楽器の種類など、ユーザーの指定に基づいて音楽を自動生成できる。", "4. 音楽生成AIは、作成された楽曲がすべて既存の作品に似ているため、独自性を持たせることは不可能である。"], answer: 2, explanation: "生成AIは、ユーザーの指定に応じて多様な音楽を生成できます。" },
        { question: "「GAN（敵対的生成ネットワーク）」における生成器と識別器の役割について誤っているものを1つ選びなさい。", options: ["1. 生成器は、ノイズを入力として現実のようなデータを生成するモデルである。", "2. 識別器は、生成器が作成したデータと実際のデータを区別しようとするモデルである。", "3. 生成器は、識別器を訓練し、より正確にデータを分類できるようにする役割を持つ。", "4. GANは、生成器と識別器が互いに競い合うことで、生成されるデータの品質を向上させる。"], answer: 2, explanation: "生成器は識別器を騙すようにデータを生成し、識別器は生成器が生成したデータを見破るように学習します。" },
        { question: "「Transformerモデル」に関する説明として正しいものを1つ選びなさい。", options: ["1. Transformerモデルは、リカレント構造を持ち、シーケンスデータの長期的依存関係を学習する。", "2. Transformerモデルは、自己注意機構（Self-Attention）を利用して、シーケンス内の異なる部分の相互関係を考慮する。", "3. Transformerモデルは、時系列データの解析には適さないため、自然言語処理以外には使用されない。", "4. Transformerモデルは、複数の層を用いてデータを処理するが、出力層ではシーケンス全体の情報を無視する。"], answer: 1, explanation: "Transformerモデルは、自己注意機構（Self-Attention）を利用して、シーケンス全体の情報を効率的に処理します。" },
        { question: "「ディープフェイク技術」に関する説明として誤っているものを1つ選びなさい。", options: ["1. ディープフェイク技術は、画像や映像において特定の人物の顔を別の顔に置き換えることができる。", "2. ディープフェイクは、主に敵対的生成ネットワーク(GAN)を利用して生成される。", "3. ディープフェイク技術は悪用されることがなく、セキュリティやプライバシーへの影響は少ない。", "4. ディープフェイク技術が進化すると、本物の映像と偽の映像を区別することが非常に難しくなる場合がある。", "4. AIは数学的に公平であるため、バイアスの影響を受けることはない。"], answer: 2, explanation: "ディープフェイク技術は悪用されるリスクがあり、セキュリティやプライバシーに大きな影響を与えます。" },
        { question: "「AIの社会的影響」に関する説明として正しいものを1つ選びなさい。", options: ["1. AIは、人間の意思決定に依存しないため、すべての結果が公平であり、バイアスが発生することはない。", "2. AIの導入により、労働市場に変化が起こり、特定の職業が自動化されることで失業リスクが増加する可能性がある。", "3. AIは、すべての分野で透明性を確保するため、どのような状況でも意思決定の過程を完全に説明できる。", "4. AI技術の進歩に伴い、データのプライバシー保護は必要なくなってきている。"], answer: 1, explanation: "AIの導入は、自動化による失業リスクなど、労働市場に影響を与える可能性があります。" },
        { question: "「AI倫理」に関する説明として誤っているものを1つ選びなさい。", options: ["1. AIシステムがバイアスのあるデータで訓練されると、そのバイアスが結果にも反映される可能性がある。", "2. AIは倫理的な課題を解決できるため、倫理に関する問題は今後発生しなくなる。", "3. AIの透明性が不足すると、意思決定のプロセスが理解されにくくなり、責任の所在が不明確になるリスクがある。", "4. AIは、プライバシー保護やデータの安全性に配慮した開発が必要とされている。"], answer: 1, explanation: "AIは倫理的な問題を引き起こす可能性があり、その解決が求められています。" },
        { question: "「生成AIのリスク」に関する説明として正しいものを1つ選びなさい。", options: ["1. 生成AIによるコンテンツは常に正確であり、誤情報やバイアスが含まれることはない。", "2. 生成AIは、フェイクコンテンツの作成に利用される可能性があり、誤った情報の拡散に寄与するリスクがある。", "3. 生成AIは、訓練データをリアルタイムでアップデートするため、常に最新の情報を基にコンテンツを作成する。", "4. 生成AIはすべての分野において透明性を保証しているため、規制や管理は不要である。"], answer: 1, explanation: "生成AIはフェイクコンテンツ作成に利用され、誤情報拡散のリスクがあります。" },
        { question: "「インターネットリテラシー」に関する説明として正しいものを1つ選びなさい。", options: ["1. インターネットリテラシーは、主に技術的スキルに依存し、情報の正確さや信頼性は考慮されない。", "2. インターネットリテラシーを高めることは、オンラインでのセキュリティやプライバシー保護に役立つ。", "3. インターネットリテラシーは、インターネットの利用に限定され、情報リテラシーとは無関係である。", "4. インターネットリテラシーが高ければ、フィッシング詐欺のリスクは完全に排除できる。"], answer: 1, explanation: "インターネットリテラシーには、情報の信頼性を判断する能力やセキュリティ対策の知識が含まれます。" },
        { question: "「個人情報保護法」に関する説明として正しいものを1つ選びなさい。", options: ["1. 個人情報保護法では、すべてのデータが個人情報として扱われるため、公開されている情報も含めて保護の対象である。", "2. 個人識別符号は、特定の個人を直接識別できる情報であり、これも個人情報保護法の対象となる。", "3. 匿名加工情報は、個人を特定できるため、同意なしに自由に利用することは許されない。", "4. 改正個人情報保護法では、要配慮個人情報に対してのみ特別な保護が求められる。"], answer: 1, explanation: "個人識別符号は、個人情報保護法の保護対象となる「個人情報」に含まれます。" },
        { question: "「AI社会原則」に関する説明として誤っているものを1つ選びなさい。", options: ["1.AI社会原則では、AIシステムの開発と使用において公平性や透明性が求められている。", "2. AI社会原則は、AI技術が進歩する中で、プライバシーやセキュリティに対する保護が不要になることを想定している。", "3. AI社会原則の一つには、AIシステムの透明性を確保し、意思決定の過程を説明可能にすることが含まれている。", "4. AIの開発においては、人間中心のアプローチを取り、人間の尊厳や自律性を尊重することが求められている。"], answer: 1, explanation: "AI社会原則は、AIの発展に伴い、プライバシーやセキュリティ保護の重要性が増すことを想定しています。" },
        { question: "「AIとプライバシー」に関する説明として誤っているものを1つ選びなさい。", options: ["1. AIは大量のデータを利用して学習するため、個人情報が含まれるデータの扱いには特別な配慮が必要である。", "2. AIシステムが学習する際に利用するデータは、すべて匿名化されているため、プライバシーの侵害は発生しない。", "3. 個人情報保護法では、AIが利用するデータにもプライバシー保護に関する規制が適用される。", "4. AIによるデータ分析では、個人を特定できないように処理を施す匿名加工情報が推奨される場合がある。"], answer: 1, explanation: "AIの学習データが必ずしもすべて匿名化されているわけではありません。" },
        { question: "「サイバーセキュリティ」に関する説明として正しいものを1つ選びなさい。", options: ["1. サイバーセキュリティは、主に物理的なセキュリティ対策に依存しており、ソフトウェアの安全性は重視されない。", "2. サイバーセキュリティは、情報システムやネットワークを保護し、データの機密性、完全性、可用性を確保するための技術である。", "3. サイバーセキュリティ対策を施すと、完全にサイバー攻撃のリスクを排除することができる。", "4. サイバーセキュリティは、ネットワーク上の脅威に対してのみ適用され、クラウド環境には適用されない。"], answer: 1, explanation: "サイバーセキュリティは、情報システムの安全性を確保するための重要な技術です。" },
        { question: "「AIに関する透明性と説明責任」に関する説明として正しいものを1つ選びなさい。", options: ["1. AIシステムは常に透明性が保証されており、すべてのプロセスが完全に理解可能である。", "2. 説明責任を果たすためには、AIシステムがどのようなデータに基づいて意思決定を行ったのかを説明できる必要がある。", "3. AIの透明性を高めると、モデルの性能が低下するため、実務での導入は推奨されない。", "4. AIの透明性は、技術者のみが理解すればよいため、一般ユーザーへの説明は不要である。"], answer: 1, explanation: "AIの説明責任を果たすためには、意思決定の根拠を明確にすることが求められます。" },
        { question: "「AIの公平性」に関する説明として誤っているものを1つ選びなさい。", options: ["1. AIシステムは、訓練データに含まれるバイアスを学習してしまい、特定のグループに対する不公平な結果を生む可能性がある。", "2. AIの公平性を確保するためには、データのバイアスを排除し、適切に多様なデータセットを使用することが重要である。", "3. AIは数学的に公平であるため、バイアスの影響を受けることはない。", "4. AIシステムの設計時には、社会的な公平性や倫理的な配慮が必要である。"], answer: 2, explanation: "AIは訓練データに含まれるバイアスを学習するため、不公平な結果を生み出す可能性があります。" }
      ]
    };

    // --- STATE MANAGEMENT ---
    let currentQuiz = [], currentIndex = 0, wrongAnswers = [], selectedChapter = "";
    let userId = null;
    let geminiApiKey = null;
    let weeklyChart = null;

    // --- INITIALIZATION ---
    window.onload = () => {
      initializeUser();
      loadApiKey();
      renderHomePage();
    };

    function initializeUser() {
      userId = localStorage.getItem('quiz_userId');
      if (!userId) {
        userId = crypto.randomUUID();
        localStorage.setItem('quiz_userId', userId);
      }
      document.getElementById('userIdFooter').textContent = `学習ID: ${userId}`;
    }

    function loadApiKey() {
      geminiApiKey = localStorage.getItem('gemini_apiKey');
    }

    // --- RENDERING ---
    function renderHomePage() {
      const app = document.getElementById("app");
      app.innerHTML = `
        <div class="flex justify-between items-center mb-4">
          <h2 class="text-2xl font-bold text-gray-800">生成AIパスポート試験問題集</h2>
          <button onclick="showApiKeyDialog()" class="text-sm bg-gray-200 hover:bg-gray-300 text-gray-700 font-bold py-1 px-3 rounded-full">⚙️ 設定</button>
        </div>
        
        <!-- Dashboard -->
        <details class="mb-4" open>
          <summary class="text-lg font-bold text-gray-700 cursor-pointer p-2 rounded-lg hover:bg-gray-100">学習ダッシュボード</summary>
          <div class="mt-2 grid grid-cols-1 md:grid-cols-2 gap-4">
              <div id="calendar-container" class="p-4 bg-gray-50 rounded-lg"></div>
              <div class="p-4 bg-gray-50 rounded-lg">
                  <canvas id="weeklyChart"></canvas>
              </div>
          </div>
        </details>
        <hr>
        
        <!-- Quiz Start -->
        <div>
            <h3 class="text-lg font-bold text-gray-700 mb-2">クイズに挑戦</h3>
            <select id="chapterSelect" class="bg-gray-50 border border-gray-300 rounded-md p-2 w-full focus:ring-2 focus:ring-blue-500 focus:border-blue-500"></select>
            <select id="questionCount" class="bg-gray-50 border border-gray-300 rounded-md p-2 w-full focus:ring-2 focus:ring-blue-500 focus:border-blue-500">
              <option value="5">5問</option>
              <option value="10" selected>10問</option>
              <option value="all">全問</option>
            </select>
            <button onclick="startQuiz()" class="bg-blue-600 hover:bg-blue-700 text-white font-bold py-3 px-4 rounded-lg">この章でクイズを始める</button>
            <button onclick="showHistoryList()" class="bg-green-600 hover:bg-green-700 text-white font-bold py-3 px-4 rounded-lg">学習履歴を見る</button>
        </div>
        <hr>

        <!-- AI Features -->
        <div>
            <h3 class="text-lg font-bold text-gray-700 mb-2">AI サポート機能</h3>
            <button onclick="askAITeacher()" class="bg-purple-600 hover:bg-purple-700 text-white font-bold py-3 px-4 rounded-lg">AI先生に質問する ✨</button>
            <button onclick="showStudyPlan()" class="bg-indigo-600 hover:bg-indigo-700 text-white font-bold py-3 px-4 rounded-lg">今日の学習プランを立てる ✨</button>
        </div>
      `;
      
      const chapterSelect = document.getElementById("chapterSelect");
      chapterSelect.innerHTML = `<option value="">章を選択してください</option>`;
      Object.keys(chapters).forEach(ch => {
        const opt = document.createElement("option");
        opt.value = ch;
        opt.textContent = ch;
        chapterSelect.appendChild(opt);
      });

      renderDashboard();
    }
    
    function renderDashboard() {
        renderCalendar();
        renderWeeklyChart();
    }

    function renderCalendar() {
        const container = document.getElementById('calendar-container');
        const history = getHistory();
        const studiedDates = history.map(record => new Date(record.date).toDateString());
        
        const now = new Date();
        const year = now.getFullYear();
        const month = now.getMonth();

        const firstDay = new Date(year, month, 1);
        const lastDay = new Date(year, month + 1, 0);

        let html = `<h4 class="font-bold text-center mb-2">${year}年 ${month + 1}月</h4>
                    <table id="calendar" class="w-full"><thead><tr>`;
        const days = ['日', '月', '火', '水', '木', '金', '土'];
        days.forEach(day => html += `<th>${day}</th>`);
        html += `</tr></thead><tbody><tr>`;

        for (let i = 0; i < firstDay.getDay(); i++) {
            html += `<td></td>`;
        }

        for (let day = 1; day <= lastDay.getDate(); day++) {
            const currentDate = new Date(year, month, day);
            if (currentDate.getDay() === 0 && day !== 1) {
                html += `</tr><tr>`;
            }
            const dateStr = currentDate.toDateString();
            let classes = [];
            if (dateStr === new Date().toDateString()) classes.push('today');
            if (studiedDates.includes(dateStr)) classes.push('studied');
            
            html += `<td class="${classes.join(' ')}">${day}</td>`;
        }
        
        html += `</tr></tbody></table>`;
        container.innerHTML = html;
    }

    function renderWeeklyChart() {
        const ctx = document.getElementById('weeklyChart').getContext('2d');
        const history = getHistory();
        const labels = [];
        const data = [];
        
        for (let i = 6; i >= 0; i--) {
            const d = new Date();
            d.setDate(d.getDate() - i);
            labels.push(`${d.getMonth() + 1}/${d.getDate()}`);
            
            const solvedCount = history
                .filter(record => new Date(record.date).toDateString() === d.toDateString())
                .reduce((sum, record) => sum + record.total, 0);
            data.push(solvedCount);
        }
        
        if(weeklyChart) weeklyChart.destroy();

        weeklyChart = new Chart(ctx, {
            type: 'bar',
            data: {
                labels: labels,
                datasets: [{
                    label: '解いた問題数',
                    data: data,
                    backgroundColor: 'rgba(59, 130, 246, 0.5)',
                    borderColor: 'rgba(59, 130, 246, 1)',
                    borderWidth: 1
                }]
            },
            options: {
                scales: {
                    y: {
                        beginAtZero: true,
                        ticks: {
                            stepSize: 1
                        }
                    }
                },
                plugins: {
                    legend: {
                        display: false
                    },
                    title: {
                        display: true,
                        text: '週間学習グラフ'
                    }
                }
            }
        });
    }

    // --- QUIZ LOGIC ---
    function shuffle(array) {
      for (let i = array.length - 1; i > 0; i--) {
        const j = Math.floor(Math.random() * (i + 1));
        [array[i], array[j]] = [array[j], array[i]];
      }
      return array;
    }

    function startQuiz() {
      const chapter = document.getElementById("chapterSelect").value;
      const count = document.getElementById("questionCount").value;
      if (!chapter) {
        showMessageDialog("エラー", "学習したい章を選択してください。");
        return;
      }
      selectedChapter = chapter;
      let questions = shuffle([...chapters[chapter]]);
      if (count !== "all") {
        questions = questions.slice(0, parseInt(count));
      }
      currentQuiz = questions;
      currentIndex = 0;
      wrongAnswers = [];
      showQuestion();
    }

    function showQuestion() {
      const q = currentQuiz[currentIndex];
      const app = document.getElementById("app");
      app.innerHTML = `
        <div class="mb-4">
          <div class="flex justify-between items-center mb-2">
            <h3 class="text-xl font-bold text-blue-600">問題 ${currentIndex + 1} / ${currentQuiz.length}</h3>
            <div class="text-sm font-semibold text-gray-600">${selectedChapter}</div>
          </div>
          <div class="p-4 bg-gray-100 rounded-lg">
            <p class="text-gray-800">${q.question}</p>
          </div>
        </div>`;
      
      q.options.forEach((opt, i) => {
        const btn = document.createElement("button");
        btn.innerHTML = `<span class="bg-blue-500 text-white rounded-full w-6 h-6 flex items-center justify-center mr-3">${i === 0 ? 'ア' : i === 1 ? 'イ' : i === 2 ? 'ウ' : 'エ'}</span> ${opt}`;
        btn.onclick = () => checkAnswer(i);
        btn.className = "bg-white hover:bg-blue-50 border border-gray-300 text-gray-800 font-semibold py-3 px-4 rounded-lg my-1 w-full text-left flex items-center transition-colors duration-200";
        app.appendChild(btn);
      });
    }

    function checkAnswer(selected) {
      const q = currentQuiz[currentIndex];
      const isCorrect = selected === q.answer;
      if (!isCorrect) {
        wrongAnswers.push({ question: q.question, answer: q.options[q.answer], explanation: q.explanation });
      } else {
        createSakuraPetals();
      }
      showResult(selected, q);
    }

    function showResult(selected, q) {
      const app = document.getElementById("app");
      const isCorrect = selected === q.answer;
      app.innerHTML = "";
      const resultDiv = document.createElement("div");
      resultDiv.className = `p-4 rounded-lg border-l-4 ${isCorrect ? 'bg-green-50 border-green-500' : 'bg-red-50 border-red-500'}`;
      resultDiv.innerHTML = `
        <h3 class="text-2xl font-bold mb-2 ${isCorrect ? 'text-green-700' : 'text-red-700'}">${isCorrect ? '✅ 正解！' : '❌ 不正解...'}</h3>
        <p class="font-semibold text-gray-700 mb-2">正解は「${q.options[q.answer]}」です。</p>
        <p class="text-gray-600">${q.explanation}</p>
      `;
      app.appendChild(resultDiv);

      const nextBtn = document.createElement("button");
      nextBtn.textContent = currentIndex < currentQuiz.length - 1 ? "次の問題へ" : "結果を見る";
      nextBtn.onclick = nextQuestion;
      nextBtn.className = "bg-blue-600 hover:bg-blue-700 text-white font-bold py-3 px-4 rounded-lg my-4 w-full";
      app.appendChild(nextBtn);
    }

    function nextQuestion() {
      currentIndex++;
      if (currentIndex < currentQuiz.length) {
        showQuestion();
      } else {
        saveHistory();
        showFinalScore();
      }
    }

    function showFinalScore() {
      const app = document.getElementById("app");
      const correctCount = currentQuiz.length - wrongAnswers.length;
      const totalCount = currentQuiz.length;
      const score = Math.round((correctCount / totalCount) * 100);

      app.innerHTML = `
        <div class="text-center">
            <h2 class="text-2xl font-bold mb-2">クイズ終了！</h2>
            <p class="text-lg text-gray-700 mb-4">${selectedChapter}</p>
            <p class="text-4xl font-bold mb-2">${correctCount} <span class="text-2xl font-normal">/ ${totalCount} 問正解</span></p>
            <p class="text-5xl font-bold text-blue-600 mb-6">${score}<span class="text-3xl">%</span></p>
        </div>
        <hr>`;

      const reviewBtn = document.createElement("button");
      reviewBtn.textContent = "間違えた問題を復習する";
      reviewBtn.onclick = () => showWrongAnswers(wrongAnswers, showFinalScore);
      reviewBtn.disabled = wrongAnswers.length === 0;
       if (wrongAnswers.length === 0) {
        reviewBtn.textContent = "全問正解です！素晴らしい！";
      }
      reviewBtn.className = "bg-yellow-500 hover:bg-yellow-600 text-white font-bold py-3 px-4 rounded-lg w-full";
      app.appendChild(reviewBtn);

      const backBtn = document.createElement("button");
      backBtn.textContent = "ホームに戻る";
      backBtn.onclick = renderHomePage;
      backBtn.className = "bg-gray-500 hover:bg-gray-600 text-white font-bold py-3 px-4 rounded-lg w-full";
      app.appendChild(backBtn);
    }
    
    // --- HISTORY MANAGEMENT ---
    function getHistory() {
        return JSON.parse(localStorage.getItem(`quiz_history_${userId}`) || "[]");
    }

    function saveHistory() {
      const newRecord = {
        date: new Date().toISOString(),
        chapter: selectedChapter,
        correct: currentQuiz.length - wrongAnswers.length,
        total: currentQuiz.length,
        wrong: wrongAnswers,
      };
      let history = getHistory();
      history.unshift(newRecord); 
      localStorage.setItem(`quiz_history_${userId}`, JSON.stringify(history.slice(0, 50))); 
    }

    function showHistoryList() {
      const history = getHistory();
      const app = document.getElementById("app");
      app.innerHTML = `
        <div class="flex justify-between items-center mb-4">
            <h2 class="text-xl font-bold">📚 学習履歴</h2>
            <button onclick="resetHistory()" class="text-sm bg-red-100 hover:bg-red-200 text-red-700 font-bold py-1 px-3 rounded-full">履歴をリセット</button>
        </div>`;
      if (history.length === 0) {
        app.innerHTML += `<p class="text-gray-600 text-center">まだ学習履歴がありません。</p>`;
      } else {
        history.forEach((record, i) => {
          const rate = Math.round((record.correct / record.total) * 100);
          const div = document.createElement("div");
          div.className = "p-4 bg-gray-50 rounded-lg mb-4";
          div.innerHTML = `
            <p class="font-semibold">${record.chapter}</p>
            <p class="text-sm text-gray-500">${new Date(record.date).toLocaleString('ja-JP')}</p>
            <p class="my-2">正解率: <span class="font-bold ${rate > 80 ? 'text-green-600' : 'text-yellow-600'}">${rate}%</span> (${record.correct}/${record.total}問)</p>
            <div class="h-2 bg-gray-200 rounded-full my-2">
              <div class="h-full bg-blue-500 rounded-full" style="width:${rate}%;"></div>
            </div>`;
          
          if (record.wrong.length > 0) {
            const reviewBtn = document.createElement("button");
            reviewBtn.textContent = `間違えた${record.wrong.length}問を復習`;
            reviewBtn.onclick = () => showWrongAnswers(record.wrong, showHistoryList);
            reviewBtn.className = "bg-yellow-500 hover:bg-yellow-600 text-white font-bold py-2 px-4 rounded-lg mt-2 w-full text-sm";
            div.appendChild(reviewBtn);
          }
          app.appendChild(div);
        });
      }
      const backBtn = document.createElement("button");
      backBtn.textContent = "ホームに戻る";
      backBtn.onclick = renderHomePage;
      backBtn.className = "bg-gray-500 hover:bg-gray-600 text-white font-bold py-2 px-4 rounded-lg mt-4 w-full";
      app.appendChild(backBtn);
    }
    
    function resetHistory() {
        if (confirm("本当にすべての学習履歴をリセットしますか？この操作は元に戻せません。")) {
            localStorage.removeItem(`quiz_history_${userId}`);
            showHistoryList();
        }
    }

    function showWrongAnswers(wrongQuestions, backFunction) {
      const app = document.getElementById("app");
      app.innerHTML = `<h2 class="text-xl font-bold mb-4">🔁 間違えた問題の復習</h2><hr>`;
      wrongQuestions.forEach((q, i) => {
        const div = document.createElement("div");
        div.className = "p-4 bg-gray-50 rounded-lg mb-4 border-l-4 border-yellow-500";
        div.innerHTML = `<p class="font-bold text-gray-800">Q: ${q.question}</p>
                         <p class="mt-2 text-green-700">✅ 正解: ${q.answer}</p>
                         <p class="mt-1 text-gray-600">📘 解説: ${q.explanation}</p>`;
        app.appendChild(div);
      });

      const backBtn = document.createElement("button");
      backBtn.textContent = "戻る";
      backBtn.onclick = backFunction;
      backBtn.className = "bg-gray-500 hover:bg-gray-600 text-white font-bold py-2 px-4 rounded-lg mt-4 w-full";
      app.appendChild(backBtn);
    }
    
    // --- API & AI FEATURES ---
    async function callGeminiAPI(prompt, systemInstruction = null) {
      if (!geminiApiKey) {
        throw new Error("API_KEY_NOT_SET");
      }
      const apiUrl = `https://generativelanguage.googleapis.com/v1beta/models/gemini-2.5-flash-preview-05-20:generateContent?key=${geminiApiKey}`;
      const payload = {
        contents: [{ parts: [{ text: prompt }] }],
        ...(systemInstruction && { systemInstruction: { parts: [{ text: systemInstruction }] } }),
      };

      let response;
      const maxRetries = 5;
      const retryableStatuses = [429, 503, 504];

      for (let i = 0; i < maxRetries; i++) {
        try {
          response = await fetch(apiUrl, {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify(payload)
          });

          if (response.ok) {
            break;
          }
          
          if (!retryableStatuses.includes(response.status)) {
             break;
          }
          
          const delay = Math.pow(2, i) * 1000 + Math.random() * 1000;
          console.log(`API call failed with status ${response.status}. Retrying in ${delay.toFixed(0)}ms...`);
          await new Promise(resolve => setTimeout(resolve, delay));
          
        } catch (error) {
          console.error("Fetch error:", error);
          if (i === maxRetries - 1) {
             throw error;
          }
          const delay = Math.pow(2, i) * 1000 + Math.random() * 1000;
          console.log(`Network error. Retrying in ${delay.toFixed(0)}ms...`);
          await new Promise(resolve => setTimeout(resolve, delay));
        }
      }

      if (!response.ok) {
        throw new Error(`API call failed with status: ${response.status}`);
      }
      const result = await response.json();
      return result.candidates?.[0]?.content?.parts?.[0]?.text || "応答がありませんでした。";
    }

    async function askAITeacher() {
        if (!geminiApiKey) {
            showApiKeyDialog("AI先生を利用するにはAPIキーの設定が必要です。");
            return;
        }
      const app = document.getElementById("app");
      app.innerHTML = `
        <h2 class="text-xl font-bold mb-4">AI先生に質問する ✨</h2>
        <p class="text-gray-600 mb-4">生成AIパスポート試験に関する質問や、間違えた問題について、AI先生に質問してみましょう。</p>
        <textarea id="aiQuestion" class="w-full h-32 p-2 border border-gray-300 rounded-lg my-4 focus:ring-2 focus:ring-blue-500" placeholder="例：AIの学習方法について、もっと詳しく教えてください。"></textarea>
        <button id="sendQuestionBtn" onclick="sendAITeacherQuestion()" class="bg-purple-600 hover:bg-purple-700 text-white font-bold py-3 px-4 rounded-lg w-full">質問を送信する</button>
        <button onclick="renderHomePage()" class="bg-gray-500 hover:bg-gray-600 text-white font-bold py-2 px-4 rounded-lg mt-2 w-full">ホームに戻る</button>
      `;

      const history = getHistory();
      if (history.length > 0 && history[0].wrong.length > 0) {
        const latestWrong = history[0].wrong;
        const wrongQuestionText = latestWrong.map(q => `- 「${q.question}」`).join('\n');
        const placeholder = `AI先生、前回のクイズで間違えた以下の問題について、もっと分かりやすく解説してください。\n\n${wrongQuestionText}`;
        document.getElementById('aiQuestion').value = placeholder;
      }
    }

    async function sendAITeacherQuestion() {
      const question = document.getElementById("aiQuestion").value;
      if (!question) {
        showMessageDialog("エラー", "質問内容を入力してください。");
        return;
      }

      showLoadingDialog("AI先生が回答を作成中です...");
      const systemPrompt = "あなたは生成AIパスポート試験の知識に非常に詳しいエキスパートであり、親切な家庭教師です。ユーザーからの質問に対して、専門用語を避け、初心者にも理解できるように具体的で分かりやすい言葉で回答してください。";
      try {
        const response = await callGeminiAPI(question, systemPrompt);
        showMessageDialog("AI先生からの回答", response);
      } catch (e) {
        handleApiError(e);
      }
    }
    
    async function showStudyPlan() {
        if (!geminiApiKey) {
            showApiKeyDialog("学習プランの作成にはAPIキーの設定が必要です。");
            return;
        }
      showLoadingDialog("あなたのための学習プランを作成中です...");
      
      const history = getHistory();
      const wrongQuestionsText = history.slice(0, 5).flatMap(r => r.wrong.map(q => q.question)).join('\n');
      
      let prompt;
      if (wrongQuestionsText.length > 0) {
        prompt = `ユーザーの直近の不正解問題のリストです：\n${wrongQuestionsText}\n\nこれらの傾向を分析し、このユーザーが次に重点的に学習すべきポイントを3つ挙げてください。そして、それぞれのポイントについて、具体的な学習アクションを提案し、励ましの言葉を添えた学習プランを作成してください。`;
      } else {
        prompt = `ユーザーはまだクイズに挑戦していないか、全問正解しています。生成AIパスポート試験のスキルをさらに向上させるための、中級者から上級者向けの学習プランを提案してください。重点ポイントを3つ挙げ、それぞれ具体的なアクションを提案してください。`;
      }

      const systemPrompt = "あなたは優秀な学習コンサルタントです。ユーザーの学習履歴（特に苦手な分野）を基に、モチベーションが上がるような、パーソナライズされた学習プランを提案してください。箇条書きを使い、簡潔で分かりやすい言葉で記述してください。";

      try {
        const response = await callGeminiAPI(prompt, systemPrompt);
        showMessageDialog("今日の学習プラン提案 ✨", response);
      } catch (e) {
        handleApiError(e);
      }
    }
    
    // --- UTILITIES & DIALOGS ---
    function showApiKeyDialog(message = "") {
        const messageHtml = message ? `<p class="text-sm text-red-600 bg-red-100 p-2 rounded-md mb-4">${message}</p>` : "";
        let dialogContainer = document.querySelector('.dialog-container');
        if (dialogContainer) dialogContainer.remove();
        
        dialogContainer = document.createElement('div');
        dialogContainer.className = 'dialog-container';
        
        const dialog = document.createElement('div');
        dialog.className = 'dialog';
        dialog.innerHTML = `
            <h3 class="text-xl font-bold mb-2">APIキー設定</h3>
            ${messageHtml}
            <p class="text-sm text-gray-600 mb-4">AI機能（AI先生、学習プラン）を利用するには、Google AI Studioで取得したGemini APIキーが必要です。</p>
            <input type="password" id="apiKeyInput" class="w-full p-2 border border-gray-300 rounded-md" placeholder="APIキーを入力...">
            <a href="https://aistudio.google.com/app/apikey" target="_blank" class="text-sm text-blue-600 hover:underline">APIキーの取得はこちら</a>
            <button onclick="saveApiKey()" class="bg-blue-600 hover:bg-blue-700 text-white font-bold py-2 px-4 rounded-lg mt-4 w-full">保存する</button>
            <button onclick="this.parentElement.parentElement.remove()" class="bg-gray-200 hover:bg-gray-300 text-gray-700 font-bold py-2 px-4 rounded-lg w-full">閉じる</button>`;
        
        dialog.querySelector('#apiKeyInput').value = geminiApiKey || '';
        dialogContainer.appendChild(dialog);
        document.body.appendChild(dialogContainer);
    }
    
    function saveApiKey() {
        const key = document.getElementById('apiKeyInput').value;
        if (key) {
            localStorage.setItem('gemini_apiKey', key);
            geminiApiKey = key;
            document.querySelector('.dialog-container')?.remove();
            showMessageDialog("成功", "APIキーを保存しました。");
        } else {
            localStorage.removeItem('gemini_apiKey');
            geminiApiKey = null;
            showMessageDialog("情報", "APIキーを削除しました。");
        }
    }
    
    function handleApiError(error) {
        if (error.message === "API_KEY_NOT_SET") {
            showApiKeyDialog("AI機能を利用するにはAPIキーの設定が必要です。");
        } else {
            console.error(error);
            showMessageDialog("エラー", "AIとの通信中にエラーが発生しました。APIキーが正しいか、ネットワーク接続を確認してください。");
        }
    }
    
    function showMessageDialog(title, content) {
      let dialogContainer = document.querySelector('.dialog-container');
      if (dialogContainer) dialogContainer.remove();
      
      dialogContainer = document.createElement('div');
      dialogContainer.className = 'dialog-container';
      
      const dialog = document.createElement('div');
      dialog.className = 'dialog';
      dialog.innerHTML = `<h3 class="text-xl font-bold mb-4">${title}</h3>
        <div class="text-gray-700 whitespace-pre-wrap">${content.replace(/\n/g, '<br>')}</div>
        <button onclick="this.parentElement.parentElement.remove()" class="bg-gray-500 hover:bg-gray-600 text-white font-bold py-2 px-4 rounded-lg mt-6 w-full">閉じる</button>`;
      
      dialogContainer.appendChild(dialog);
      document.body.appendChild(dialogContainer);
    }

    function showLoadingDialog(title) {
       let dialogContainer = document.querySelector('.dialog-container');
      if (dialogContainer) dialogContainer.remove();
      
      dialogContainer = document.createElement('div');
      dialogContainer.className = 'dialog-container';
      
      const dialog = document.createElement('div');
      dialog.className = 'dialog flex flex-col items-center';
      dialog.innerHTML = `<h3 class="text-xl font-bold mb-4">${title}</h3><div class="spinner"></div>`;
      
      dialogContainer.appendChild(dialog);
      document.body.appendChild(dialogContainer);
    }
    
    // Function to create and animate sakura petals
    function createSakuraPetals() {
      const petalContainer = document.querySelector('.sakura-container') || document.createElement('div');
      petalContainer.className = 'sakura-container';
      if (!document.querySelector('.sakura-container')) {
          document.body.appendChild(petalContainer);
      }

      for (let i = 0; i < 20; i++) {
        const petal = document.createElement('div');
        petal.className = 'sakura-petal';
        const startX = Math.random() * window.innerWidth;
        const duration = 5 + Math.random() * 5; // 5-10s
        const delay = Math.random() * 2; // 0-2s delay
        const direction = Math.random() > 0.5 ? 1 : -1;
        
        petal.style.left = `${startX}px`;
        petal.style.animationName = 'fall';
        petal.style.animationDuration = `${duration}s`;
        petal.style.animationDelay = `${delay}s`;
        petal.style.animationTimingFunction = `cubic-bezier(0.25, ${0.1 + Math.random() * 0.4}, 0.25, 1)`;
        
        petalContainer.appendChild(petal);
        
        setTimeout(() => {
          petal.remove();
        }, (duration + delay) * 1000);
      }
    }
  </script>
</body>
</html>
