<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8">
  <title>生成AIパスポート試験問題集_V11_章別復習モード</title>
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <script src="https://cdn.tailwindcss.com"></script>
  <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;700&family=Noto+Sans+JP:wght@400;700&display=swap" rel="stylesheet">
  <style>
    body { font-family: 'Noto Sans JP', 'Inter', sans-serif; background-color: #f0f4f8; padding: 20px; }
    .card { background: white; padding: 24px; border-radius: 12px; box-shadow: 0 4px 12px rgba(0,0,0,0.08); max-width: 650px; margin: auto; }
    button, select { margin-top: 12px; padding: 12px; font-size: 16px; width: 100%; border-radius: 8px; border: 1px solid #d1d5db; transition: all 0.2s ease-in-out; }
    button:hover:not(:disabled) { transform: translateY(-2px); box-shadow: 0 2px 6px rgba(0,0,0,0.1); }
    button:disabled { background-color: #d1d5db; cursor: not-allowed; }
    .small { font-size: 14px; color: #4b5563; }
    hr { margin: 24px 0; border-color: #e5e7eb; }
    .dialog-container { position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.5); display: flex; justify-content: center; align-items: center; z-index: 1000; opacity: 0; animation: fadeIn 0.3s forwards; }
    .dialog { background: white; padding: 24px; border-radius: 12px; box-shadow: 0 10px 25px rgba(0,0,0,0.1); max-width: 90%; width: 500px; max-height: 80%; overflow-y: auto; transform: scale(0.95); animation: zoomIn 0.3s forwards; }
    .spinner { border: 4px solid rgba(0, 0, 0, 0.1); width: 36px; height: 36px; border-radius: 50%; border-left-color: #3b82f6; animation: spin 1s ease infinite; }
    @keyframes spin { to { transform: rotate(360deg); } }
    @keyframes fadeIn { to { opacity: 1; } }
    @keyframes zoomIn { to { transform: scale(1); } }
    /* Calendar Styles */
    #calendar { font-size: 14px; }
    #calendar th, #calendar td { text-align: center; padding: 8px; }
    #calendar td.today { background-color: #fef3c7; border-radius: 50%; }
    #calendar td.studied { background-color: #93c5fd; color: white; border-radius: 50%; font-weight: bold; }
    /* Sakura Petals */
    .sakura-container {
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        pointer-events: none;
        overflow: hidden;
        z-index: 999;
    }
    .sakura-petal {
        position: absolute;
        width: 15px;
        height: 15px;
        background-color: #ffc0cb;
        border-radius: 50% 10% 50% 10%;
        transform: rotate(45deg);
        opacity: 0;
        animation: fall linear infinite;
    }
    @keyframes fall {
        0% {
            transform: translate(0, -100px) rotate(0deg);
            opacity: 1;
        }
        100% {
            transform: translate(50px, 100vh) rotate(360deg);
            opacity: 0;
        }
    }
  </style>
</head>
<body>
  <div class="card" id="app">
    <!-- Main content will be rendered here -->
  </div>

  <div id="userIdFooter" class="text-center text-xs text-gray-400 mt-4"></div>
  
  <script>
    // --- DATA ---
    const chapters = {
      "第1章 AI（人工知能）": [
        // 基礎問題
        { question: "次のうち、「AI(人工知能)」と「ロボット」の区別に関する説明として誤っているものを1つ選びなさい。", options: ["1.AIはデータを分析し、学習して知識を構築するが、物理的な操作を行うことはない。", "2.ロボットは物理的な作業を行うが、AIのようにデータを分析したり学習する能力は持っていない。", "3.AIはソフトウェアであり、物理的な形を持たないが、ロボットはハードウェアとして存在する。", "4.ロボットはAI技術を利用して自律的に学習し、周囲の環境に適応することができる。"], answer: 1, explanation: "ロボットはAIを内蔵することで、AIのようにデータを分析したり学習する能力を持つことができます。" },
        { question: "次のうち、「教師なし学習」に関する説明として誤っているものを1つ選びなさい。", options: ["1.教師なし学習では、ラベルの付いていないデータを用いてモデルをトレーニングし、データの構造やパターンを発見する。", "2.教師なし学習の代表的な手法には、クラスタリングや次元削減が含まれる。", "3.教師なし学習では、モデルは与えられた正解に基づいてフィードバックを受け、予測精度を向上させる。", "4.教師なし学習は、データの分類や特徴量の抽出など、さまざまなタスクに応用される。"], answer: 2, explanation: "「正解に基づくフィードバック」は教師あり学習の特徴です。" },
        { question: "次のうち、「AIの歴史」に関する説明として誤っているものを1つ選びなさい。", options: ["1.第一次AIブームは、主に探索と推論の技術を中心に発展した。", "2.第二次AIブームでは、エキスパートシステムが広く利用されるようになったが、ブームは終息し「AIの冬」と呼ばれる時期が訪れた。", "3.第三次AIブームは、ビッグデータの活用とディープラーニングの発展によって引き起こされた。", "4.第三次AIブーム以降、AIは特に金融業界にのみ限定して応用されている。"], answer: 3, explanation: "AIは金融業界だけでなく、医療、製造、交通など多岐にわたる分野で応用されています。" },
        { question: "次のうち、「強化学習」に関する説明として正しいものを1つ選びなさい。", options: ["1.強化学習では、エージェントがすべての行動に対して即座に報酬を受け取る。", "2.強化学習の目標は、長期的な報酬を最大化する行動方針（ポリシー）を学習することである。", "3.強化学習は、教師あり学習と異なり、学習には事前にラベル付けされたデータが必要である。", "4.強化学習では、探索と利用のバランスを取る必要がなく、常に最良の既知の行動を選択すればよい。"], answer: 1, explanation: "強化学習は、報酬を最大化する最適な行動方針を学習することを目的としています。" },
        { question: "次のうち、「ニューラルネットワーク」に関する説明として正しいものを1つ選びなさい。", options: ["1.ニューラルネットワークは、全てのノードが互いに接続されているため、計算コストが常に一定である。", "2.ニューラルネットワークの隠れ層の数を増やすと、必ずしもモデルの性能が向上するわけではない。", "3.ニューラルネットワークは、線形回帰モデルと同じ手法を用いて訓練される。", "4.ニューラルネットワークの出力層は、必ずソフトマックス関数を使用して確率分布を計算する。"], answer: 1, explanation: "隠れ層を増やしすぎると、過学習を起こし、モデルの性能が低下する場合があります。" },
        { question: "次のうち、「クラスタリング」に関する説明として誤っているものを1つ選びなさい。", options: ["1.クラスタリングは、教師なし学習の一種であり、データを類似性に基づいてグループ分けする手法である。", "2.K-means法は、クラスタリングの代表的な手法の一つで、データポイントをK個のクラスタに分割する。", "3.クラスタリングの結果は、クラスタの数を変更しても必ず同じになるため、一度の計算で十分である。", "4.階層的クラスタリングは、データポイント間の距離を基に、段階的にクラスタを形成していく手法である。"], answer: 2, explanation: "クラスタリングの結果は、クラスタ数や初期値によって変動することがあります。" },
        // 応用・シラバス詳細キーワード問題
        { question: "「ノーフリーランチ定理」に関する説明として正しいものを1つ選びなさい。", options: ["1. ノーフリーランチ定理は、あるアルゴリズムが全ての問題において最適な性能を発揮することを示している。", "2. ノーフリーランチ定理は、アルゴリズムの性能が特定の問題においてのみ有効であり、全ての問題に対して均一に効果的ではないことを示している。", "3. ノーフリーランチ定理は、最適なアルゴリズムを選択すれば、問題の種類に関わらず常に最高の結果を得られると述べている。", "4. ノーフリーランチ定理は、どのアルゴリズムもデータの種類に関係なく、同等の結果をもたらすことを示している。"], answer: 1, explanation: "ノーフリーランチ定理は、あるアルゴリズムが万能ではないことを示しています。" },
        { question: "「シンギュラリティ（技術的特異点）」に関する説明として誤っているものを1つ選びなさい。", options: ["1.シンギュラリティは、AIが人間の知能を超える技術的特異点のことであり、将来のある時点で到来する可能性があるとされている。", "2.シンギュラリティに達すると、AIは自己改善を繰り返し、人間が予測不能な形で進化を遂げるとされている。", "3.シンギュラリティは、ヴァーナー・ヴィンジやレイ・カーツワイルによって提唱された概念である。", "4.シンギュラリティが到来すると、AIの進化は人間の制御下に留まり、完全に予測可能な結果を生むとされている。"], answer: 3, explanation: "シンギュラリティは、AIの進化が人間の制御を離れ、予測不能な変化をもたらすとされています。" },
        { question: "「転移学習」に関する説明として誤っているものを1つ選びなさい。", options: ["1.転移学習は、あるタスクで訓練されたモデルを別のタスクに適用することができる。", "2. 転移学習は、特定のタスクに対して完全に新しいモデルをゼロから訓練する必要がない。", "3. 転移学習は、大量のデータを使ったモデルでなければ効果を発揮しない。", "4. 転移学習は、元のタスクで学習した知識を新しいタスクに応用するため、少量のデータでも高精度な結果が得られることが多い。"], answer: 2, explanation: "転移学習は、データが少ない場合でも高い効果を発揮します。" },
        { question: "「データの次元削減」に関する説明として正しいものを1つ選びなさい。", options: ["1. 次元削減は、データの特徴量を増やすことで、より複雑なモデルを構築するための手法である。", "2. 主成分分析（PCA）は、データの分散を最大化する新しい軸を見つけて、次元を削減する手法の一つである。", "3. 次元削減を行うと、常にモデルの性能が低下するため、基本的に使用すべきではない。", "4. 次元削減は、すべてのデータの特徴量をランダムに削除することで、データ量を削減する手法である。"], answer: 1, explanation: "主成分分析（PCA）は、データの持つ情報をできるだけ保持しつつ、次元を削減する手法です。" },
      ],
      "第2章 生成AI": [
        // 基礎問題
        { question: "次のうち、「生成AI (ジェネレーティブAI)」に関する説明として適切でないものを1つ選びなさい。", options: ["1.生成AIは新しいデータを生成するために、既存のデータパターンを学習する。", "2.生成AIにはGANやVAEなどのモデルが含まれる。", "3.生成AIは主に画像や音声の生成に使用され、テキストの生成には適用されない。", "4.Transformerモデルは、生成AIの一種であり、テキスト生成に優れた性能を持つ。"], answer: 2, explanation: "生成AIはテキスト生成にも広く活用されています。" },
        { question: "次のうち、「生成AI (ジェネレーティブAI)」の仕組みに関する説明として正しいものを1つ選びなさい。", options: ["1.GAN(敵対的生成ネットワーク)は、二つのモデルが協力して新しいデータを生成する手法である。", "2.VAE(変分自己符号化器)は、生成されるデータの潜在ベクトルを固定しておくことで、より多様なデータを生成することができる。", "3.Transformerモデルは、主にシーケンスデータを扱う際に使用されるが、その内部にリカレント層を持つため、処理速度が遅くなる傾向がある。", "4.自己回帰モデルは、出力される値が次の入力に依存するため、時系列データの生成に適している。"], answer: 3, explanation: "自己回帰モデルは、前の出力が次の入力となる性質から、時系列データやテキスト生成に適しています。" },
        { question: "「自然言語処理（NLP）」に関する説明として正しいものを1つ選びなさい。", options: ["1.自然言語処理は、テキストデータの処理に特化しており、音声や画像データの処理には適用されない。", "2.NLPでは、テキストの単語順序を無視して解析を行うため、文の意味を完全に理解することはできない。", "3.トークナイゼーションは、テキストを単語や文などの単位に分割する自然言語処理の基本的な手法である。", "4.自然言語処理のモデルは、言語ごとに完全に異なる手法で訓練される必要があるため、汎用的なモデルは存在しない。"], answer: 2, explanation: "トークナイゼーションは、NLPにおける前処理の重要なステップです。" },
        { question: "「GAN（敵対的生成ネットワーク）」に関する説明として正しいものを1つ選びなさい。", options: ["1. GANは、一つのニューラルネットワークを用いてデータを生成し、別のモデルと競合することなく学習を進める。", "2. GANは、生成器と識別器の二つのモデルが競合することで、生成されるデータの品質を向上させる。", "3. GANは、生成器のみが学習を行い、識別器は事前に固定されたパラメータを使用する。", "4. GANは、生成器が作成したデータをすべて正解としてラベル付けし、識別器を訓練する。"], answer: 1, explanation: "GANは、生成器と識別器が互いに競い合いながら学習を進めることで、より高品質なデータを生成します。" },
        { question: "「Transformerモデル」に関する説明として誤っているものを1つ選びなさい。", options: ["1.Transformerモデルは、並列処理が可能であり、従来のRNNよりも効率的にシーケンスデータを処理できる。", "2.TransformerモデルのAttention機構は、入力シーケンス全体にわたって関連性の高い部分に重点を置いて処理を行う。", "3.Transformerモデルは、リカレント層を使用しているため、長いシーケンスの処理に時間がかかる。", "4.Transformerモデルは、自然言語処理の分野で高い性能を発揮し、多くの言語モデルで採用されている。"], answer: 2, explanation: "Transformerモデルはリカレント層を使用せず、Attention機構によって並列処理が可能です。" },
        { question: "「LSTM（長・短期記憶）」に関する説明として正しいものを1つ選びなさい。", options: ["1. LSTMは、従来のRNNと異なり、長期的な依存関係を学習することができるが、短期的な依存関係は無視される。", "2. LSTMは、内部にゲート構造を持ち、過去の情報を選択的に保持または忘却することで、長期的な依存関係を学習できる。", "3. LSTMは、一般的にシーケンスデータの処理には適用されず、画像認識に特化している。", "4. LSTMは、訓練中に長期的な情報を完全に保持するため、勾配消失問題が起こりやすい。"], answer: 1, explanation: "LSTMは、ゲート構造により長期的な依存関係を学習することができ、勾配消失問題を軽減します。" },
        // 応用・シラバス詳細キーワード問題
        { question: "「GAN（敵対的生成ネットワーク）」における生成器と識別器の役割について誤っているものを1つ選びなさい。", options: ["1. 生成器は、ノイズを入力として現実のようなデータを生成するモデルである。", "2. 識別器は、生成器が作成したデータと実際のデータを区別しようとするモデルである。", "3. 生成器は、識別器を訓練し、より正確にデータを分類できるようにする役割を持つ。", "4. GANは、生成器と識別器が互いに競い合うことで、生成されるデータの品質を向上させる。"], answer: 2, explanation: "生成器は識別器を騙すようにデータを生成し、識別器は生成器が生成したデータを見破るように学習します。" },
        { question: "「Attention機構」に関する説明として正しいものを1つ選びなさい。", options: ["1.Attention機構は、シーケンス全体の情報を均等に重み付けして処理を行う手法である。", "2. Attention機構は、入力シーケンスの中で重要な部分に焦点を当てて重み付けを行い、より関連性の高い情報を強調する手法である。", "3. Attention機構は、主に画像データの処理に特化しており、テキストデータの処理には適用されない。", "4. Attention機構を用いると、モデルの訓練が不安定になるため、自然言語処理では避けるべきである。"], answer: 1, explanation: "Attention機構は、入力シーケンス内で重要な部分に注目して処理を行う仕組みです。" },
        { question: "「生成AIモデルのハルシネーション（幻覚）」に関する説明として誤っているものを1つ選びなさい。", options: ["1. ハルシネーションは、生成AIモデルが実際には存在しない情報を出力する現象である。", "2. ハルシネーションは、モデルが未学習のデータに対して推測を行った結果、誤った情報を生成することが原因である。", "3. ハルシネーションが発生するのは、主に音声認識モデルに限定されており、テキスト生成モデルでは起こらない。", "4. ハルシネーションを減らすためには、より多様で高品質なデータを用いたモデルの訓練が有効である。"], answer: 2, explanation: "ハルシネーションはテキスト生成モデルでも頻繁に発生します。" },
        { question: "「生成AIモデルによるテキスト生成」に関する説明として誤っているものを1つ選びなさい。", options: ["1. テキスト生成モデルは、自然言語処理に基づいて、入力されたコンテキストに応じた文章を生成する。", "2. 大規模言語モデル（LLM）は、膨大なデータセットを使って事前に訓練され、その後、特定のタスクに応じて微調整されることが多い。", "3. テキスト生成AIは、最新のニュースや事実に基づいた正確な情報を常に提供する。", "4. モデルのトレーニングデータに依存するため、生成AIが不正確な情報やバイアスを含むテキストを生成するリスクがある。"], answer: 2, explanation: "生成AIは、学習データに基づいて情報を生成するため、常に最新で正確な情報を提供できるとは限りません。" },
      ],
      "第3章 生成AIの動向": [
        // 基礎問題
        { question: "次のうち、「生成AIのビジネス応用」に関する説明として正しいものを1つ選びなさい。", options: ["1.生成AIは、ビジネスにおいて画像や動画の生成に特化しており、テキスト生成にはほとんど利用されない。", "2.生成AIを活用することで、アンケート項目の自動生成やデータの分析が効率化される。", "3.生成AIは、主にマーケティング分野で使用され、他の業務分野ではほとんど使用されない。", "4.生成AIを使って作成されたビジネス書類は、法的に有効とされることはない。"], answer: 1, explanation: "生成AIはテキスト生成にも活用され、ビジネス文書作成やアンケート作成などを効率化できます。" },
        { question: "次のうち、「ディープフェイク技術」に関する説明として正しいものを1つ選びなさい。", options: ["1.ディープフェイク技術は、従来のビデオ編集ソフトウェアを使用して作成されるため、高度なAI技術を必要としない。", "2.ディープフェイクは、AIによって生成された音声や映像を本物と区別することが非常に困難になることがある。", "3.ディープフェイク技術の進歩により、現在ではディープフェイクを作成する際に膨大なデータや時間は必要なくなった。", "4.ディープフェイクは、主にエンターテイメントやゲームの分野でのみ利用され、他の分野での影響は限定的である。"], answer: 1, explanation: "AIによって生成されたコンテンツは、真実と見分けるのが難しい場合があります。" },
        // 応用・シラバス詳細キーワード問題
        { question: "「ディープフェイク技術」に関する説明として誤っているものを1つ選びなさい。", options: ["1. ディープフェイク技術は、画像や映像において特定の人物の顔を別の顔に置き換えることができる。", "2. ディープフェイクは、主に敵対的生成ネットワーク(GAN)を利用して生成される。", "3. ディープフェイク技術は悪用されることがなく、セキュリティやプライバシーへの影響は少ない。", "4. ディープフェイク技術が進化すると、本物の映像と偽の映像を区別することが非常に難しくなる場合がある。"], answer: 2, explanation: "ディープフェイク技術は悪用されるリスクがあり、セキュリティやプライバシーに大きな影響を与えます。" },
        { question: "「生成AIによるフェイクコンテンツ」に関する説明として正しいものを1つ選びなさい。", options: ["1.生成AIによるフェイクコンテンツは、技術的に簡単に見分けることができるため、社会的な影響は少ない。", "2.生成AIが作成したフェイクコンテンツは、拡散される前に常にAIによって自動的に検出される。", "3.生成AIによるフェイクコンテンツは、真実の情報と区別が難しい場合があり、社会的混乱や誤情報の拡散につながる可能性がある。", "4.生成AIによるフェイクコンテンツは、エンターテイメント分野に限定して使用され、他の分野には影響を与えない。"], answer: 2, explanation: "生成AIによるフェイクコンテンツは、誤情報拡散のリスクを伴います。" },
      ],
      "第4章 情報リテラシー・基本理念とAI社会原則": [
        // 基礎問題
        { question: "次のうち、「セキュリティとプライバシー」に関する説明として誤っているものを1つ選びなさい。", options: ["1.フィッシング詐欺は、インターネット利用者を騙し、個人情報を盗むために行われる詐欺の一種である。", "2.スミッシングは、メールを通じて送信された悪意のあるリンクをクリックさせることで、個人情報を取得しようとする攻撃手法である。", "3.QRコードを悪用した攻撃では、偽のQRコードを使用してユーザーを悪意のあるウェブサイトに誘導することができる。", "4.ソーシャルエンジニアリング攻撃は、人間の心理的な弱点をついて情報を引き出す手法であり、インターネットに限定された攻撃ではない。"], answer: 1, explanation: "スミッシングはSMS（ショートメッセージサービス）を利用した詐欺です。" },
        { question: "次のうち、「AIの倫理的課題」に関する説明として誤っているものを1つ選びなさい。", options: ["1.AIシステムが導入されることで、従来の労働市場が変動し、職業の自動化により失業リスクが増加する可能性がある。", "2.AIの意思決定プロセスがブラックボックス化することで、責任の所在が不明確になる懸念がある。", "3.AIはプライバシー保護の観点から、個人情報を収集する際に事前の許可が不要とされる。", "4.バイアスのあるデータで訓練されたAIは、特定の人種や性別に対する差別的な結果を生む可能性がある。"], answer: 2, explanation: "個人情報の収集には、事前の許可や同意が原則として必要です。" },
        { question: "「インターネットリテラシー」に関する説明として正しいものを1つ選びなさい。", options: ["1. インターネットリテラシーは、主に技術的スキルに依存し、情報の正確さや信頼性は考慮されない。", "2. インターネットリテラシーを高めることは、オンラインでのセキュリティやプライバシー保護に役立つ。", "3. インターネットリテラシーは、インターネットの利用に限定され、情報リテラシーとは無関係である。", "4. インターネットリテラシーが高ければ、フィッシング詐欺のリスクは完全に排除できる。"], answer: 1, explanation: "インターネットリテラシーには、情報の信頼性を判断する能力やセキュリティ対策の知識が含まれます。" },
        { question: "「個人情報保護法」に関する説明として正しいものを1つ選びなさい。", options: ["1. 個人情報保護法では、すべてのデータが個人情報として扱われるため、公開されている情報も含めて保護の対象である。", "2. 個人識別符号は、特定の個人を直接識別できる情報であり、これも個人情報保護法の対象となる。", "3. 匿名加工情報は、個人を特定できるため、同意なしに自由に利用することは許されない。", "4. 改正個人情報保護法では、要配慮個人情報に対してのみ特別な保護が求められる。"], answer: 1, explanation: "個人識別符号は、個人情報保護法の保護対象となる「個人情報」に含まれます。" },
        // 応用・シラバス詳細キーワード問題
        { question: "「AI社会原則」に関する説明として誤っているものを1つ選びなさい。", options: ["1.AI社会原則では、AIシステムの開発と使用において公平性や透明性が求められている。", "2. AI社会原則は、AI技術が進歩する中で、プライバシーやセキュリティに対する保護が不要になることを想定している。", "3. AI社会原則の一つには、AIシステムの透明性を確保し、意思決定の過程を説明可能にすることが含まれている。", "4. AIの開発においては、人間中心のアプローチを取り、人間の尊厳や自律性を尊重することが求められている。"], answer: 1, explanation: "AI社会原則は、AIの発展に伴い、プライバシーやセキュリティ保護の重要性が増すことを想定しています。" },
        { question: "「AIとプライバシー」に関する説明として誤っているものを1つ選びなさい。", options: ["1. AIは大量のデータを利用して学習するため、個人情報が含まれるデータの扱いには特別な配慮が必要である。", "2. AIシステムが学習する際に利用するデータは、すべて匿名化されているため、プライバシーの侵害は発生しない。", "3. 個人情報保護法では、AIが利用するデータにもプライバシー保護に関する規制が適用される。", "4. AIによるデータ分析では、個人を特定できないように処理を施す匿名加工情報が推奨される場合がある。"], answer: 1, explanation: "AIの学習データが必ずしもすべて匿名化されているわけではありません。" },
        { question: "「サイバーセキュリティ」に関する説明として正しいものを1つ選びなさい。", options: ["1. サイバーセキュリティは、主に物理的なセキュリティ対策に依存しており、ソフトウェアの安全性は重視されない。", "2. サイバーセキュリティは、情報システムやネットワークを保護し、データの機密性、完全性、可用性を確保するための技術である。", "3. サイバーセキュリティ対策を施すと、完全にサイバー攻撃のリスクを排除することができる。", "4. サイバーセキュリティは、ネットワーク上の脅威に対してのみ適用され、クラウド環境には適用されない。"], answer: 1, explanation: "サイバーセキュリティは、情報システムの安全性を確保するための重要な技術です。" },
        { question: "「AIに関する透明性と説明責任」に関する説明として正しいものを1つ選びなさい。", options: ["1. AIシステムは常に透明性が保証されており、すべてのプロセスが完全に理解可能である。", "2. 説明責任を果たすためには、AIシステムがどのようなデータに基づいて意思決定を行ったのかを説明できる必要がある。", "3. AIの透明性を高めると、モデルの性能が低下するため、実務での導入は推奨されない。", "4. AIの透明性は、技術者のみが理解すればよいため、一般ユーザーへの説明は不要である。"], answer: 1, explanation: "AIの説明責任を果たすためには、意思決定の根拠を明確にすることが求められます。" },
        { question: "「AIの公平性」に関する説明として誤っているものを1つ選びなさい。", options: ["1. AIシステムは、訓練データに含まれるバイアスを学習してしまい、特定のグループに対する不公平な結果を生む可能性がある。", "2. AIの公平性を確保するためには、データのバイアスを排除し、適切に多様なデータセットを使用することが重要である。", "3. AIは数学的に公平であるため、バイアスの影響を受けることはない。", "4. AIシステムの設計時には、社会的な公平性や倫理的な配慮が必要である。"], answer: 2, explanation: "AIは訓練データに含まれるバイアスを学習するため、不公平な結果を生み出す可能性があります。" },
        // 追加問題
        { question: "「Dignity（人間の尊厳が尊重される社会）」とは、以下のうちどれが最も適切ですか。", options: ["1. 人間がAIを道具として使いこなし、人間の能力を最大限に発揮する社会", "2. AIの意思決定プロセスがすべて公開され、誰でもその理由を理解できる社会", "3. AI技術によって社会の経済格差が完全に解消された社会", "4. AIが人間の知能を超越し、人間の生活を完全にサポートする社会"], answer: 0, explanation: "Dignityは、AIを道具として活用し、人間の尊厳と自律性を尊重する「人間中心の社会」を目指すというAI社会原則の基本理念の一つです。" },
        { question: "「Sustainability（持続可能な社会）」に関するAI社会原則の考え方として適切なものはどれですか。", options: ["1. AIの開発コストを削減し、企業の利益を最大化すること", "2. 地球規模の環境問題や気候変動など、持続可能性の課題にAI技術で対応すること", "3. AIの進化を優先し、既存の法律や規制を一時的に無視すること", "4. すべてのAIをオープンソース化し、技術的な透明性を確保すること"], answer: 1, explanation: "Sustainabilityは、AI技術を地球規模の課題解決に役立て、持続的な発展を目指すというAI社会原則の基本理念の一つです。" },
        { question: "AIの事業活動を担う3つの主体の一つである「AI Developer（AI開発者）」の定義として正しいものはどれですか。", options: ["1. 実際にAIシステムを利用してビジネスを行う事業者", "2. AIシステムを開発し、提供する事業者", "3. AIシステムの倫理的な影響を評価する機関", "4. AIが生成したコンテンツの著作権を主張する個人"], answer: 1, explanation: "AI Developerは、AIシステムを開発する事業者を指します。利用するのはAI Business User、提供するのはAI Providerです。" },
        { question: "生成AIの技術的発展に潜む脅威に関する説明として、**不適切**なものはどれですか。", options: ["1. 攻撃者が（詐欺師など）の準備にかかる時間的・金銭的コストが削減される。", "2. ディープフェイク技術により、偽情報が広く拡散され、社会的な混乱を引き起こす。", "3. AIが生成した悪質なコードにより、サイバー攻撃の成功率が向上する。", "4. AIのセキュリティ対策が不要になり、システム管理者の負担が軽減される。"], answer: 3, explanation: "AI技術の発展は、攻撃者の準備コストを削減したり、偽情報の拡散を容易にしたりする脅威があります。しかし、「AIのセキュリティ対策が不要になる」というのは誤りであり、むしろ対策はより重要になっています。" },
        { question: "不正競争防止法において、「不正競争に該当しない」行為の**例外**として認められるものはどれですか。", options: ["1. 他社の有名ブランド名をそのまま自社商品のキャッチコピーとして使用すること。", "2. 広く知られた普通名称や慣用表示を用いたり、販売後3年を経過した商品の形態を模倣すること。", "3. 他社のロゴデザインをそのまま模倣し、自社製品パッケージに使用すること。", "4. 他社の営業秘密を不正な手段で取得し、自社製品の開発に利用すること。"], answer: 1, explanation: "不正競争防止法では、普通名称や慣用表示、または販売から一定期間（3年）が経過した商品の形態の模倣は、原則として不正競争に該当しない**例外**とされています。これに対し、他社のロゴや営業秘密の不正利用は、不正競争防止法の対象となります。" }
      ],
      "💡学習・モデル詳解": [
        { question: "「ファインチューニング」と「プレトレーニング」の違いに関する説明として正しいものを1つ選びなさい。", options: ["1. プレトレーニングはラベル付きデータで行い、ファインチューニングはラベルなしデータで行う。", "2. プレトレーニングは特定のタスクに特化し、ファインチューニングは広範な知識を習得する。", "3. プレトレーニングで広範な基礎知識を習得し、ファインチューニングで特定のタスク向けに調整する。", "4. 両者とも訓練に使用するデータは同じであり、工程の順序だけが異なる。",], answer: 2, explanation: "プレトレーニングは大量のデータで広範な知識を学習させ、ファインチューニングは特定のタスク向けの少量のデータでモデルを調整するプロセスです。" },
        { question: "「プレトレーニング」に関する説明として誤っているものを1つ選びなさい。", options: ["1. 大量のラベルなしテキストデータを使用して、言語の基本的なパターンや構造を学習させるプロセスである。", "2. モデルが一度に広範な知識を獲得し、その後のファインチューニングの基礎となる。", "3. 特定のタスクに特化したデータのみを使用し、モデルの精度を最大化することを目的とする。", "4. 通常、大規模言語モデル（LLM）の構築における最初のステップである。",], answer: 2, explanation: "特定のタスクに特化したデータを使うのは「ファインチューニング」であり、プレトレーニングは広範なテキストデータを使用します。" },
        { question: "ニューラルモデルにおける「Temperature」パラメータの役割として最も適切なものを1つ選びなさい。", options: ["1. モデルが学習する際のデータ量を決定する。", "2. モデルの出力におけるランダム性や創造性を調整する。", "3. モデルの訓練中に過学習を防ぐために使用される。", "4. モデルが出力するテキストの最大長を制限する。",], answer: 1, explanation: "Temperatureを高くするとランダム性が増し、創造的なテキストが生成されます。低くすると予測性が高まり、安定したテキストになります。" },
        { question: "「アーリーストッピング」に関する説明として適切なものを1つ選びなさい。", options: ["1. 訓練データをランダムに削除し、過学習を防ぐ手法である。", "2. モデルの性能がテストデータで向上しなくなった時点で訓練を早期に終了させる手法である。", "3. モデルが訓練データに過度に適応することを促進する手法である。", "4. モデルの最終層の重みだけを更新する手法である。",], answer: 1, explanation: "アーリーストッピングは、モデルの性能が頭打ちになったり低下し始めたりするのを検知し、過学習を避けるために訓練を中断する手法です。" },
      ],
      "🚨応用・頻出ミス問題": [
        { question: "「GAN（敵対的生成ネットワーク）」における生成器と識別器の役割について誤っているものを1つ選びなさい。", options: ["1. 生成器は、ノイズを入力として現実のようなデータを生成するモデルである。", "2. 識別器は、生成器が作成したデータと実際のデータを区別しようとするモデルである。", "3. 生成器は、識別器を訓練し、より正確にデータを分類できるようにする役割を持つ。", "4. GANは、生成器と識別器が互いに競い合うことで、生成されるデータの品質を向上させる。"], answer: 2, explanation: "生成器は識別器を騙すようにデータを生成し、識別器は生成器が生成したデータを見破るように学習します。" },
        { question: "「Transformerモデル」に関する説明として誤っているものを1つ選びなさい。", options: ["1.Transformerモデルは、並列処理が可能であり、従来のRNNよりも効率的にシーケンスデータを処理できる。", "2.TransformerモデルのAttention機構は、入力シーケンス全体にわたって関連性の高い部分に重点を置いて処理を行う。", "3.Transformerモデルは、リカレント層を使用しているため、長いシーケンスの処理に時間がかかる。", "4.Transformerモデルは、自然言語処理の分野で高い性能を発揮し、多くの言語モデルで採用されている。"], answer: 2, explanation: "Transformerモデルはリカレント層を使用せず、Attention機構によって並列処理が可能です。" },
        { question: "「AIによる画像認識技術」に関する説明として誤っているものを1つ選びなさい。", options: ["1. 画像認識技術では、畳み込みニューラルネットワーク（CNN）が広く使用されている。", "2. CNNは、画像データの空間的構造を保持しながら特徴を抽出することに優れている。", "3. 画像認識モデルは、訓練データと異なる視点や角度の画像には適用できない。", "4. データ拡張技術を用いることで、訓練データのバリエーションを増やし、画像認識モデルの汎化性能を向上させることができる。"], answer: 2, explanation: "画像認識モデルは、未知のデータにも適用できるように汎化性能を高めることが重要です。" },
        { question: "「過学習（オーバーフィッティング）」に関する説明として誤っているものを1つ選びなさい。", options: ["1. 過学習は、モデルが訓練データに過度に適応し、未知のデータに対しては性能が低下する現象である。", "2. 過学習を防ぐために、ドロップアウトや正則化などの手法が使用される。", "3. 過学習は、訓練データが十分に多ければ発生しないため、常にデータを増やすことが推奨される。", "4. 過学習が発生すると、モデルはノイズや無関係なパターンを学習し、汎化性能が低下する。"], answer: 2, explanation: "訓練データが多ければ過学習は起こりにくくなりますが、完全に防げるわけではありません。" },
        { question: "「RNN（リカレントニューラルネットワーク）」に関する説明として誤っているものを1つ選びなさい。", options: ["1.RNNは、シーケンスデータの各要素を順番に処理し、過去の情報を考慮しながら出力を生成する。", "2. RNNは、バックプロパゲーションによって訓練されるが、勾配消失問題が発生しやすい。", "3. RNNは、長期的な依存関係を学習するのに適しているため、LSTMやGRUはほとんど使われない。", "4. RNNは、時系列データや自然言語処理のタスクで広く使用されている。"], answer: 2, explanation: "RNNは長期的な依存関係の学習が苦手であり、その問題を解決するためにLSTMやGRUが開発されました。" },
        // 追加問題
        { question: "「不正競争防止法」に関する説明として、以下のうち最も**不適切**なものはどれですか。", options: ["1. 他社のロゴデザインをそのまま模倣し、自社製品パッケージに使用すること。", "2. 広く知られた普通名称や慣用表示を用いたり、販売後3年を経過した商品の形態を模倣すること。", "3. 他社の営業秘密を不正な手段で取得し、自社製品の開発に利用すること。", "4. 他社のサービスマークに類似したマークを自社サービスに使用すること。"], answer: 1, explanation: "普通名称や慣用表示の使用、または販売後3年が経過した商品の形態の模倣は、原則として不正競争に該当しない**例外**とされています。これに対し、他社のロゴや営業秘密の不正利用は、不正競争防止法の対象となります。" }
      ]
    };

    // --- STATE MANAGEMENT ---
    let currentQuiz = [], currentIndex = 0, wrongAnswers = [], selectedChapter = "";
    let userId = null;
    let geminiApiKey = null;
    let weeklyChart = null;

    // --- INITIALIZATION ---
    window.onload = () => {
      initializeUser();
      loadApiKey();
      renderHomePage();
    };

    function initializeUser() {
      userId = localStorage.getItem('quiz_userId');
      if (!userId) {
        userId = crypto.randomUUID();
        localStorage.setItem('quiz_userId', userId);
      }
      document.getElementById('userIdFooter').textContent = `学習ID: ${userId}`;
    }

    function loadApiKey() {
      geminiApiKey = localStorage.getItem('gemini_apiKey');
    }

    // --- RENDERING ---
    function renderHomePage() {
      const app = document.getElementById("app");
      app.innerHTML = `
        <div class="flex justify-between items-center mb-4">
          <h2 class="text-2xl font-bold text-gray-800">生成AIパスポート試験問題集</h2>
          <button onclick="showApiKeyDialog()" class="text-sm bg-gray-200 hover:bg-gray-300 text-gray-700 font-bold py-1 px-3 rounded-full">⚙️ 設定</button>
        </div>
        
        <!-- Dashboard -->
        <details class="mb-4" open>
          <summary class="text-lg font-bold text-gray-700 cursor-pointer p-2 rounded-lg hover:bg-gray-100">学習ダッシュボード</summary>
          <div class="mt-2 grid grid-cols-1 md:grid-cols-2 gap-4">
              <div id="calendar-container" class="p-4 bg-gray-50 rounded-lg"></div>
              <div class="p-4 bg-gray-50 rounded-lg">
                  <canvas id="weeklyChart"></canvas>
              </div>
          </div>
        </details>
        <hr>
        
        <!-- Quiz Start -->
        <div>
            <h3 class="text-lg font-bold text-gray-700 mb-2">クイズに挑戦</h3>
            <select id="chapterSelect" class="bg-gray-50 border border-gray-300 rounded-md p-2 w-full focus:ring-2 focus:ring-blue-500 focus:border-blue-500"></select>
            <select id="questionCount" class="bg-gray-50 border border-gray-300 rounded-md p-2 w-full focus:ring-2 focus:ring-blue-500 focus:border-blue-500">
              <option value="5">5問</option>
              <option value="10" selected>10問</option>
              <option value="all">全問</option>
            </select>
            <button onclick="startQuiz()" class="bg-blue-600 hover:bg-blue-700 text-white font-bold py-3 px-4 rounded-lg">この章でクイズを始める</button>
            <button onclick="showHistoryList()" class="bg-green-600 hover:bg-green-700 text-white font-bold py-3 px-4 rounded-lg">学習履歴を見る</button>
        </div>
        <hr>

        <!-- AI Features -->
        <div>
            <h3 class="text-lg font-bold text-gray-700 mb-2">AI サポート機能</h3>
            <button onclick="askAITeacher()" class="bg-purple-600 hover:bg-purple-700 text-white font-bold py-3 px-4 rounded-lg">AI先生に質問する ✨</button>
            <button onclick="showStudyPlan()" class="bg-indigo-600 hover:bg-indigo-700 text-white font-bold py-3 px-4 rounded-lg">今日の学習プランを立てる ✨</button>
        </div>
      `;
      
      const chapterSelect = document.getElementById("chapterSelect");
      chapterSelect.innerHTML = `<option value="">章を選択してください</option>`;
      Object.keys(chapters).forEach(ch => {
        const opt = document.createElement("option");
        opt.value = ch;
        opt.textContent = ch;
        chapterSelect.appendChild(opt);
      });

      renderDashboard();
    }
    
    function renderDashboard() {
        renderCalendar();
        renderWeeklyChart();
    }

    function renderCalendar() {
        const container = document.getElementById('calendar-container');
        const history = getHistory();
        const studiedDates = history.map(record => new Date(record.date).toDateString());
        
        const now = new Date();
        const year = now.getFullYear();
        const month = now.getMonth();

        const firstDay = new Date(year, month, 1);
        const lastDay = new Date(year, month + 1, 0);

        let html = `<h4 class="font-bold text-center mb-2">${year}年 ${month + 1}月</h4>
                    <table id="calendar" class="w-full"><thead><tr>`;
        const days = ['日', '月', '火', '水', '木', '金', '土'];
        days.forEach(day => html += `<th>${day}</th>`);
        html += `</tr></thead><tbody><tr>`;

        for (let i = 0; i < firstDay.getDay(); i++) {
            html += `<td></td>`;
        }

        for (let day = 1; day <= lastDay.getDate(); day++) {
            const currentDate = new Date(year, month, day);
            if (currentDate.getDay() === 0 && day !== 1) {
                html += `</tr><tr>`;
            }
            const dateStr = currentDate.toDateString();
            let classes = [];
            if (dateStr === new Date().toDateString()) classes.push('today');
            if (studiedDates.includes(dateStr)) classes.push('studied');
            
            html += `<td class="${classes.join(' ')}">${day}</td>`;
        }
        
        html += `</tr></tbody></table>`;
        container.innerHTML = html;
    }

    function renderWeeklyChart() {
        const ctx = document.getElementById('weeklyChart').getContext('2d');
        const history = getHistory();
        const labels = [];
        const data = [];
        
        for (let i = 6; i >= 0; i--) {
            const d = new Date();
            d.setDate(d.getDate() - i);
            labels.push(`${d.getMonth() + 1}/${d.getDate()}`);
            
            const solvedCount = history
                .filter(record => new Date(record.date).toDateString() === d.toDateString())
                .reduce((sum, record) => sum + record.total, 0);
            data.push(solvedCount);
        }
        
        if(weeklyChart) weeklyChart.destroy();

        weeklyChart = new Chart(ctx, {
            type: 'bar',
            data: {
                labels: labels,
                datasets: [{
                    label: '解いた問題数',
                    data: data,
                    backgroundColor: 'rgba(59, 130, 246, 0.5)',
                    borderColor: 'rgba(59, 130, 246, 1)',
                    borderWidth: 1
                }]
            },
            options: {
                scales: {
                    y: {
                        beginAtZero: true,
                        ticks: {
                            stepSize: 1
                        }
                    }
                },
                plugins: {
                    legend: {
                        display: false
                    },
                    title: {
                        display: true,
                        text: '週間学習グラフ'
                    }
                }
            }
        });
    }

    // --- QUIZ LOGIC ---
    function shuffle(array) {
      for (let i = array.length - 1; i > 0; i--) {
        const j = Math.floor(Math.random() * (i + 1));
        [array[i], array[j]] = [array[j], array[i]];
      }
      return array;
    }

    function startQuiz() {
      const chapter = document.getElementById("chapterSelect").value;
      const count = document.getElementById("questionCount").value;
      if (!chapter) {
        showMessageDialog("エラー", "学習したい章を選択してください。");
        return;
      }
      selectedChapter = chapter;
      let questions = shuffle([...chapters[chapter]]);
      if (count !== "all") {
        questions = questions.slice(0, parseInt(count));
      }
      currentQuiz = questions;
      currentIndex = 0;
      wrongAnswers = [];
      showQuestion();
    }
    
    // --- 新しい復習モードの開始関数 ---
    function startReviewQuiz(chapter, questionsToReview) {
        if (questionsToReview.length === 0) {
            showMessageDialog("情報", `${chapter}には復習すべき問題がありません！`);
            return;
        }

        selectedChapter = `🔄 復習: ${chapter}`;
        currentQuiz = shuffle(questionsToReview); // 復習問題もランダムに出題
        currentIndex = 0;
        wrongAnswers = [];
        showQuestion();
    }


    function showQuestion() {
      const q = currentQuiz[currentIndex];
      const app = document.getElementById("app");
      app.innerHTML = `
        <div class="mb-4">
          <div class="flex justify-between items-center mb-2">
            <h3 class="text-xl font-bold text-blue-600">問題 ${currentIndex + 1} / ${currentQuiz.length}</h3>
            <div class="text-sm font-semibold text-gray-600">${selectedChapter}</div>
          </div>
          <div class="p-4 bg-gray-100 rounded-lg">
            <p class="text-gray-800">${q.question}</p>
          </div>
        </div>`;
      
      q.options.forEach((opt, i) => {
        const btn = document.createElement("button");
        btn.innerHTML = `<span class="bg-blue-500 text-white rounded-full w-6 h-6 flex items-center justify-center mr-3">${i === 0 ? 'ア' : i === 1 ? 'イ' : i === 2 ? 'ウ' : 'エ'}</span> ${opt}`;
        btn.onclick = () => checkAnswer(i);
        btn.className = "bg-white hover:bg-blue-50 border border-gray-300 text-gray-800 font-semibold py-3 px-4 rounded-lg my-1 w-full text-left flex items-center transition-colors duration-200";
        app.appendChild(btn);
      });
    }

    function checkAnswer(selected) {
      const q = currentQuiz[currentIndex];
      const isCorrect = selected === q.answer;
      if (!isCorrect) {
        // 復習モードでも再度間違えた問題は記録
        wrongAnswers.push({ question: q.question, answer: q.options[q.answer], explanation: q.explanation });
      } else {
        createSakuraPetals();
      }
      showResult(selected, q);
    }

    function showResult(selected, q) {
      const app = document.getElementById("app");
      const isCorrect = selected === q.answer;
      app.innerHTML = "";
      const resultDiv = document.createElement("div");
      resultDiv.className = `p-4 rounded-lg border-l-4 ${isCorrect ? 'bg-green-50 border-green-500' : 'bg-red-50 border-red-500'}`;
      resultDiv.innerHTML = `
        <h3 class="text-2xl font-bold mb-2 ${isCorrect ? 'text-green-700' : 'text-red-700'}">${isCorrect ? '✅ 正解！' : '❌ 不正解...'}</h3>
        <p class="font-semibold text-gray-700 mb-2">正解は「${q.options[q.answer]}」です。</p>
        <p class="text-gray-600">${q.explanation}</p>
      `;
      app.appendChild(resultDiv);

      const nextBtn = document.createElement("button");
      nextBtn.textContent = currentIndex < currentQuiz.length - 1 ? "次の問題へ" : "結果を見る";
      nextBtn.onclick = nextQuestion;
      nextBtn.className = "bg-blue-600 hover:bg-blue-700 text-white font-bold py-3 px-4 rounded-lg my-4 w-full";
      app.appendChild(nextBtn);
    }

    function nextQuestion() {
      currentIndex++;
      if (currentIndex < currentQuiz.length) {
        showQuestion();
      } else {
        // 復習クイズの結果は履歴に保存しない（純粋な弱点克服のため）
        if (!selectedChapter.startsWith('🔄 復習:')) {
           saveHistory();
        }
        showFinalScore();
      }
    }

    function showFinalScore() {
      const app = document.getElementById("app");
      const correctCount = currentQuiz.length - wrongAnswers.length;
      const totalCount = currentQuiz.length;
      const score = Math.round((correctCount / totalCount) * 100);

      app.innerHTML = `
        <div class="text-center">
            <h2 class="text-2xl font-bold mb-2">クイズ終了！</h2>
            <p class="text-lg text-gray-700 mb-4">${selectedChapter}</p>
            <p class="text-4xl font-bold mb-2">${correctCount} <span class="text-2xl font-normal">/ ${totalCount} 問正解</span></p>
            <p class="text-5xl font-bold text-blue-600 mb-6">${score}<span class="text-3xl">%</span></p>
        </div>
        <hr>`;

      const reviewBtn = document.createElement("button");
      reviewBtn.textContent = "間違えた問題を復習する";
      reviewBtn.onclick = () => showWrongAnswers(wrongAnswers, showFinalScore);
      reviewBtn.disabled = wrongAnswers.length === 0;
       if (wrongAnswers.length === 0) {
        reviewBtn.textContent = "全問正解です！素晴らしい！";
      }
      reviewBtn.className = "bg-yellow-500 hover:bg-yellow-600 text-white font-bold py-3 px-4 rounded-lg w-full";
      app.appendChild(reviewBtn);

      const backBtn = document.createElement("button");
      backBtn.textContent = "ホームに戻る";
      backBtn.onclick = renderHomePage;
      backBtn.className = "bg-gray-500 hover:bg-gray-600 text-white font-bold py-3 px-4 rounded-lg w-full";
      app.appendChild(backBtn);
    }
    
    // --- HISTORY MANAGEMENT ---
    function getHistory() {
        return JSON.parse(localStorage.getItem(`quiz_history_${userId}`) || "[]");
    }

    function saveHistory() {
      const newRecord = {
        date: new Date().toISOString(),
        chapter: selectedChapter,
        correct: currentQuiz.length - wrongAnswers.length,
        total: currentQuiz.length,
        wrong: wrongAnswers,
      };
      let history = getHistory();
      history.unshift(newRecord); 
      localStorage.setItem(`quiz_history_${userId}`, JSON.stringify(history.slice(0, 50))); 
    }

    function showHistoryList() {
      const history = getHistory();
      const app = document.getElementById("app");
      app.innerHTML = `
        <div class="flex justify-between items-center mb-4">
            <h2 class="text-xl font-bold">📚 学習履歴</h2>
            <button onclick="resetHistory()" class="text-sm bg-red-100 hover:bg-red-200 text-red-700 font-bold py-1 px-3 rounded-full">履歴をリセット</button>
        </div>
        <div id="chapterReviewList" class="mt-4"></div>
        <hr>`;
      
      if (history.length === 0) {
        app.innerHTML += `<p class="text-gray-600 text-center">まだ学習履歴がありません。</p>`;
      } else {
        
        // 1. 章ごとの間違えた問題を抽出
        const wrongByChapter = {};
        const allChapters = Object.keys(chapters);
        
        // 全ての章をキーとして初期化
        allChapters.forEach(ch => wrongByChapter[ch] = []);

        history.forEach(record => {
            // 復習クイズの結果は無視する
            if (record.chapter.startsWith('🔄 復習:')) return;
            
            // 間違いが記録されている章に追記
            if (wrongByChapter[record.chapter]) {
                record.wrong.forEach(q => {
                    // 重複を防ぐための簡易チェック（質問文が一致するか）
                    if (!wrongByChapter[record.chapter].some(existingQ => existingQ.question === q.question)) {
                        // オプションと正解インデックスを復元するためにchaptersから対応する問題を探す
                        const originalQ = chapters[record.chapter].find(orig => orig.question === q.question);
                        if(originalQ) {
                             wrongByChapter[record.chapter].push(originalQ);
                        } else {
                            // もしオリジナルが見つからなくても、最低限の情報で復習できるようにする
                            // ただし、この問題は出題されなくなるため、ここでは表示しない
                        }
                    }
                });
            }
        });
        
        // 2. 章別復習リストを表示
        const reviewListDiv = document.getElementById('chapterReviewList');
        let hasReviewItems = false;
        
        Object.keys(wrongByChapter).forEach(chapterName => {
            const wrongCount = wrongByChapter[chapterName].length;
            if (wrongCount > 0) {
                hasReviewItems = true;
                const div = document.createElement("div");
                div.className = "p-4 bg-red-50 border border-red-200 rounded-lg mb-2 flex justify-between items-center";
                div.innerHTML = `
                    <div class="flex flex-col">
                        <p class="font-bold text-gray-800">${chapterName}</p>
                        <p class="text-sm text-red-600">🔁 復習すべき問題: ${wrongCount}問</p>
                    </div>`;
                
                const reviewBtn = document.createElement("button");
                reviewBtn.textContent = `復習開始 (${Math.min(wrongCount, 10)}問)`;
                reviewBtn.className = "bg-red-500 hover:bg-red-600 text-white font-bold py-2 px-4 rounded-lg w-auto whitespace-nowrap ml-4";
                
                // 復習用の問題リストを取得し、最大10問に制限してシャッフル
                let questionsToReview = shuffle(wrongByChapter[chapterName]).slice(0, 10);

                reviewBtn.onclick = () => startReviewQuiz(chapterName, questionsToReview);
                
                div.appendChild(reviewBtn);
                reviewListDiv.appendChild(div);
            }
        });
        
        if (!hasReviewItems) {
             reviewListDiv.innerHTML = `<p class="text-gray-600 text-center p-4">復習すべき間違えた問題はありません。素晴らしいです！</p>`;
        }
        
        // 3. 全履歴リストを表示
        app.innerHTML += `<h3 class="text-lg font-bold text-gray-700 mt-6 mb-2">全クイズ実行履歴</h3>`;
        history.forEach((record, i) => {
          const rate = Math.round((record.correct / record.total) * 100);
          const div = document.createElement("div");
          div.className = "p-4 bg-gray-50 rounded-lg mb-4";
          div.innerHTML = `
            <p class="font-semibold">${record.chapter}</p>
            <p class="text-sm text-gray-500">${new Date(record.date).toLocaleString('ja-JP')}</p>
            <p class="my-2">正解率: <span class="font-bold ${rate > 80 ? 'text-green-600' : 'text-yellow-600'}">${rate}%</span> (${record.correct}/${record.total}問)</p>
            <div class="h-2 bg-gray-200 rounded-full my-2">
              <div class="h-full bg-blue-500 rounded-full" style="width:${rate}%;"></div>
            </div>`;
          
          if (record.wrong.length > 0 && !record.chapter.startsWith('🔄 復習:')) {
            const reviewBtn = document.createElement("button");
            reviewBtn.textContent = `この回の間違えた${record.wrong.length}問を復習`;
            reviewBtn.onclick = () => showWrongAnswers(record.wrong, showHistoryList);
            reviewBtn.className = "bg-yellow-500 hover:bg-yellow-600 text-white font-bold py-2 px-4 rounded-lg mt-2 w-full text-sm";
            div.appendChild(reviewBtn);
          }
          app.appendChild(div);
        });
      }
      
      const backBtn = document.createElement("button");
      backBtn.textContent = "ホームに戻る";
      backBtn.onclick = renderHomePage;
      backBtn.className = "bg-gray-500 hover:bg-gray-600 text-white font-bold py-2 px-4 rounded-lg mt-4 w-full";
      app.appendChild(backBtn);
      
      // reviewListDivをappのinnerHTMLに追加した後に再挿入
      const existingHr = app.querySelector('hr');
      app.insertBefore(reviewListDiv, existingHr ? existingHr.nextSibling : app.lastChild);
    }

    function resetHistory() {
        if (confirm("本当にすべての学習履歴をリセットしますか？この操作は元に戻せません。")) {
            localStorage.removeItem(`quiz_history_${userId}`);
            showHistoryList();
        }
    }

    function showWrongAnswers(wrongQuestions, backFunction) {
      const app = document.getElementById("app");
      app.innerHTML = `<h2 class="text-xl font-bold mb-4">🔁 間違えた問題の復習（${wrongQuestions.length}問）</h2><hr>`;
      
      const startQuizBtn = document.createElement("button");
      startQuizBtn.textContent = "このリストで復習クイズを始める";
      startQuizBtn.className = "bg-red-500 hover:bg-red-600 text-white font-bold py-3 px-4 rounded-lg w-full mb-4";
      // 復習リストの問題をクイズ形式で開始
      startQuizBtn.onclick = () => {
          selectedChapter = `🚨 個別復習リスト`;
          currentQuiz = wrongQuestions;
          currentIndex = 0;
          wrongAnswers = [];
          showQuestion();
      };
      app.appendChild(startQuizBtn);

      wrongQuestions.forEach((q, i) => {
        const div = document.createElement("div");
        div.className = "p-4 bg-gray-50 rounded-lg mb-4 border-l-4 border-yellow-500";
        div.innerHTML = `<p class="font-bold text-gray-800">Q: ${q.question}</p>
                         <p class="mt-2 text-green-700">✅ 正解: ${q.answer}</p>
                         <p class="mt-1 text-gray-600">📘 解説: ${q.explanation}</p>`;
        app.appendChild(div);
      });

      const backBtn = document.createElement("button");
      backBtn.textContent = "戻る";
      backBtn.onclick = backFunction;
      backBtn.className = "bg-gray-500 hover:bg-gray-600 text-white font-bold py-2 px-4 rounded-lg mt-4 w-full";
      app.appendChild(backBtn);
    }
    
    // --- API & AI FEATURES ---
    async function callGeminiAPI(prompt, systemInstruction = null) {
      if (!geminiApiKey) {
        throw new Error("API_KEY_NOT_SET");
      }
      const apiUrl = `https://generativelanguage.googleapis.com/v1beta/models/gemini-2.5-flash-preview-05-20:generateContent?key=${geminiApiKey}`;
      const payload = {
        contents: [{ parts: [{ text: prompt }] }],
        ...(systemInstruction && { systemInstruction: { parts: [{ text: systemInstruction }] } }),
      };

      let response;
      const maxRetries = 5;
      const retryableStatuses = [429, 503, 504];

      for (let i = 0; i < maxRetries; i++) {
        try {
          response = await fetch(apiUrl, {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify(payload)
          });

          if (response.ok) {
            break;
          }
          
          if (!retryableStatuses.includes(response.status)) {
             break;
          }
          
          const delay = Math.pow(2, i) * 1000 + Math.random() * 1000;
          console.log(`API call failed with status ${response.status}. Retrying in ${delay.toFixed(0)}ms...`);
          await new Promise(resolve => setTimeout(resolve, delay));
          
        } catch (error) {
          console.error("Fetch error:", error);
          if (i === maxRetries - 1) {
             throw error;
          }
          const delay = Math.pow(2, i) * 1000 + Math.random() * 1000;
          console.log(`Network error. Retrying in ${delay.toFixed(0)}ms...`);
          await new Promise(resolve => setTimeout(resolve, delay));
        }
      }

      if (!response.ok) {
        throw new Error(`API call failed with status: ${response.status}`);
      }
      const result = await response.json();
      return result.candidates?.[0]?.content?.parts?.[0]?.text || "応答がありませんでした。";
    }

    async function askAITeacher() {
        if (!geminiApiKey) {
            showApiKeyDialog("AI先生を利用するにはAPIキーの設定が必要です。");
            return;
        }
      const app = document.getElementById("app");
      app.innerHTML = `
        <h2 class="text-xl font-bold mb-4">AI先生に質問する ✨</h2>
        <p class="text-gray-600 mb-4">生成AIパスポート試験に関する質問や、間違えた問題について、AI先生に質問してみましょう。</p>
        <textarea id="aiQuestion" class="w-full h-32 p-2 border border-gray-300 rounded-lg my-4 focus:ring-2 focus:ring-blue-500" placeholder="例：AIの学習方法について、もっと詳しく教えてください。"></textarea>
        <button id="sendQuestionBtn" onclick="sendAITeacherQuestion()" class="bg-purple-600 hover:bg-purple-700 text-white font-bold py-3 px-4 rounded-lg w-full">質問を送信する</button>
        <button onclick="renderHomePage()" class="bg-gray-500 hover:bg-gray-600 text-white font-bold py-2 px-4 rounded-lg mt-2 w-full">ホームに戻る</button>
      `;

      const history = getHistory();
      if (history.length > 0 && history[0].wrong.length > 0) {
        const latestWrong = history[0].wrong;
        const wrongQuestionText = latestWrong.map(q => `- 「${q.question}」`).join('\n');
        const placeholder = `AI先生、前回のクイズで間違えた以下の問題について、もっと分かりやすく解説してください。\n\n${wrongQuestionText}`;
        document.getElementById('aiQuestion').value = placeholder;
      }
    }

    async function sendAITeacherQuestion() {
      const question = document.getElementById("aiQuestion").value;
      if (!question) {
        showMessageDialog("エラー", "質問内容を入力してください。");
        return;
      }

      showLoadingDialog("AI先生が回答を作成中です...");
      const systemPrompt = "あなたは生成AIパスポート試験の知識に非常に詳しいエキスパートであり、親切な家庭教師です。ユーザーからの質問に対して、専門用語を避け、初心者にも理解できるように具体的で分かりやすい言葉で回答してください。";
      try {
        const response = await callGeminiAPI(question, systemPrompt);
        showMessageDialog("AI先生からの回答", response);
      } catch (e) {
        handleApiError(e);
      }
    }
    
    async function showStudyPlan() {
        if (!geminiApiKey) {
            showApiKeyDialog("学習プランの作成にはAPIキーの設定が必要です。");
            return;
        }
      showLoadingDialog("あなたのための学習プランを作成中です...");
      
      const history = getHistory();
      const wrongQuestionsText = history.slice(0, 5).flatMap(r => r.wrong.map(q => q.question)).join('\n');
      
      let prompt;
      if (wrongQuestionsText.length > 0) {
        prompt = `ユーザーの直近の不正解問題のリストです：\n${wrongQuestionsText}\n\nこれらの傾向を分析し、このユーザーが次に重点的に学習すべきポイントを3つ挙げてください。そして、それぞれのポイントについて、具体的な学習アクションを提案し、励ましの言葉を添えた学習プランを作成してください。`;
      } else {
        prompt = `ユーザーはまだクイズに挑戦していないか、全問正解しています。生成AIパスポート試験のスキルをさらに向上させるための、中級者から上級者向けの学習プランを提案してください。重点ポイントを3つ挙げ、それぞれ具体的なアクションを提案してください。`;
      }

      // 汎用的な励ましの言葉から始めるようにシステムプロンプトを修正
      const systemPrompt = "あなたは優秀な学習コンサルタントです。ユーザーの学習履歴（特に苦手な分野）を基に、モチベーションが上がるような、パーソナライズされた学習プランを提案してください。回答は必ず「学習おつかれさまです！今日の学習プランを提案します！」から始めるか、または単に「今日の学習プラン」という見出しから始めるなど、汎用的な励ましの言葉や見出しから始め、ユーザーの名前を特定するような挨拶（例：○○さん、こんにちは）は絶対に避けてください。箇条書きを使い、簡潔で分かりやすい言葉で記述してください。";

      try {
        const response = await callGeminiAPI(prompt, systemPrompt);
        showMessageDialog("今日の学習プラン提案 ✨", response);
      } catch (e) {
        handleApiError(e);
      }
    }
    
    // --- UTILITIES & DIALOGS ---
    function showApiKeyDialog(message = "") {
        const messageHtml = message ? `<p class="text-sm text-red-600 bg-red-100 p-2 rounded-md mb-4">${message}</p>` : "";
        let dialogContainer = document.querySelector('.dialog-container');
        if (dialogContainer) dialogContainer.remove();
        
        dialogContainer = document.createElement('div');
        dialogContainer.className = 'dialog-container';
        
        const dialog = document.createElement('div');
        dialog.className = 'dialog';
        dialog.innerHTML = `
            <h3 class="text-xl font-bold mb-2">APIキー設定</h3>
            ${messageHtml}
            <p class="text-sm text-gray-600 mb-4">AI機能（AI先生、学習プラン）を利用するには、Google AI Studioで取得したGemini APIキーが必要です。</p>
            <input type="password" id="apiKeyInput" class="w-full p-2 border border-gray-300 rounded-md" placeholder="APIキーを入力...">
            <a href="https://aistudio.google.com/app/apikey" target="_blank" class="text-sm text-blue-600 hover:underline">APIキーの取得はこちら</a>
            <button onclick="saveApiKey()" class="bg-blue-600 hover:bg-blue-700 text-white font-bold py-2 px-4 rounded-lg mt-4 w-full">保存する</button>
            <button onclick="this.parentElement.parentElement.remove()" class="bg-gray-200 hover:bg-gray-300 text-gray-700 font-bold py-2 px-4 rounded-lg w-full">閉じる</button>`;
        
        dialog.querySelector('#apiKeyInput').value = geminiApiKey || '';
        dialogContainer.appendChild(dialog);
        document.body.appendChild(dialogContainer);
    }
    
    function saveApiKey() {
        const key = document.getElementById('apiKeyInput').value;
        if (key) {
            localStorage.setItem('gemini_apiKey', key);
            geminiApiKey = key;
            document.querySelector('.dialog-container')?.remove();
            showMessageDialog("成功", "APIキーを保存しました。");
        } else {
            localStorage.removeItem('gemini_apiKey');
            geminiApiKey = null;
            showMessageDialog("情報", "APIキーを削除しました。");
        }
    }
    
    function handleApiError(error) {
        if (error.message === "API_KEY_NOT_SET") {
            showApiKeyDialog("AI機能を利用するにはAPIキーの設定が必要です。");
        } else {
            console.error(error);
            showMessageDialog("エラー", "AIとの通信中にエラーが発生しました。APIキーが正しいか、ネットワーク接続を確認してください。");
        }
    }
    
    function showMessageDialog(title, content) {
      let dialogContainer = document.querySelector('.dialog-container');
      if (dialogContainer) dialogContainer.remove();
      
      dialogContainer = document.createElement('div');
      dialogContainer.className = 'dialog-container';
      
      const dialog = document.createElement('div');
      dialog.className = 'dialog';
      dialog.innerHTML = `<h3 class="text-xl font-bold mb-4">${title}</h3>
        <div class="text-gray-700 whitespace-pre-wrap">${content.replace(/\n/g, '<br>')}</div>
        <button onclick="this.parentElement.parentElement.remove()" class="bg-gray-500 hover:bg-gray-600 text-white font-bold py-2 px-4 rounded-lg mt-6 w-full">閉じる</button>`;
      
      dialogContainer.appendChild(dialog);
      document.body.appendChild(dialogContainer);
    }

    function showLoadingDialog(title) {
       let dialogContainer = document.querySelector('.dialog-container');
      if (dialogContainer) dialogContainer.remove();
      
      dialogContainer = document.createElement('div');
      dialogContainer.className = 'dialog-container';
      
      const dialog = document.createElement('div');
      dialog.className = 'dialog flex flex-col items-center';
      dialog.innerHTML = `<h3 class="text-xl font-bold mb-4">${title}</h3><div class="spinner"></div>`;
      
      dialogContainer.appendChild(dialog);
      document.body.appendChild(dialogContainer);
    }
    
    // Function to create and animate sakura petals
    function createSakuraPetals() {
      const petalContainer = document.querySelector('.sakura-container') || document.createElement('div');
      petalContainer.className = 'sakura-container';
      if (!document.querySelector('.sakura-container')) {
          document.body.appendChild(petalContainer);
      }

      for (let i = 0; i < 20; i++) {
        const petal = document.createElement('div');
        petal.className = 'sakura-petal';
        const startX = Math.random() * window.innerWidth;
        const duration = 5 + Math.random() * 5; // 5-10s
        const delay = Math.random() * 2; // 0-2s delay
        const direction = Math.random() > 0.5 ? 1 : -1;
        
        petal.style.left = `${startX}px`;
        petal.style.animationName = 'fall';
        petal.style.animationDuration = `${duration}s`;
        petal.style.animationDelay = `${delay}s`;
        petal.style.animationTimingFunction = `cubic-bezier(0.25, ${0.1 + Math.random() * 0.4}, 0.25, 1)`;
        
        petalContainer.appendChild(petal);
        
        setTimeout(() => {
          petal.remove();
        }, (duration + delay) * 1000);
      }
    }
  </script>
</body>
</html>
